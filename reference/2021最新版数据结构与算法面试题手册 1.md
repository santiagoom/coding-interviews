# 2021最新版数据结构与算法⾯试题⼿册

题⽬来源⽹络，涉版权问题联系删除

1 | Java ⼯程师

1.1 | 哈希

 请说⼀说，Java中的HashMap的⼯作原理是什么？

参考回答：

HashMap类有⼀个叫做Entry的内部类。这个Entry类包含了key-value作为实例变量。 每当往

hashmap⾥⾯存放key-value对的时候，都会为它们实例化⼀个Entry对象，这个Entry对象就

会存储在前⾯提到的Entry数组table中。Entry具体存在table的那个位置是 根据key的

hashcode()⽅法计算出来的hash值（来决定）。

 介绍⼀下，什么是Hashmap?

参考回答：

HashMap 是⼀个散列表，它存储的内容是键值对(key-value)映射。

HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接⼝。

HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此

外，HashMap中的映射不是有序的。

HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因⼦”。容量 是哈希表中桶的

数量，初始容量 只是哈希表在创建时的容量。加载因⼦ 是哈希表在其容量⾃动增加之前可以

达到多满的⼀种尺度。当哈希表中的条⽬数超出了加载因⼦与当前容量的乘积时，则要对该哈

希表进⾏ rehash 操作（即重建内部数据结构），从⽽哈希表将具有⼤约两倍的桶数。

通常，默认加载因⼦是 0.75, 这是在时间和空间成本上寻求⼀种折衷。加载因⼦过⾼虽然减少

了空间开销，但同时也增加了查询成本（在⼤多数 HashMap 类的操作中，包

括 get 和 put 操作，都反映了这⼀点）。在设置初始容量时应该考虑到映射中所需的条⽬数

及其加载因⼦，以便最⼤限度地减少 rehash 操作次数。如果初始容量⼤于最⼤条⽬数除以加

载因⼦，则不会发⽣ rehash 操作。

hashmap共有4个构造函数：

// 默认构造函数。HashMap()

// 指定“容量⼤⼩”的构造函数

HashMap(int capacity)

// 指定“容量⼤⼩”和“加载因⼦”的构造函数

HashMap(int capacity, ﬂoat loadFactor)

// 包含“⼦Map”的构造函数

HashMap(Map<? extends K, ? extends V> map)

 讲⼀讲，如何构造⼀致性哈希算法。

参考回答：

先构造⼀个⻓度为232的整数环（这个环被称为⼀致性Hash环），根据节点名称的Hash值

（其分布为[0, 232-1]）将服务器节点放置在这个Hash环上，然后根据数据的Key值计算得到

其Hash值（其分布也为[0, 232-1]），接着在Hash环上顺时针查找距离这个Key值的Hash值

最近的服务器节点，完成Key到服务器的映射查找。

这种算法解决了普通余数Hash算法伸缩性差的问题，可以保证在上线、下线服务器的情况下

尽量有多的请求命中原来路由到的服务器。

 请谈⼀谈，hashCode() 和equals() ⽅法的重要性体现在什么地⽅？

参考回答：

Java中的HashMap使⽤hashCode()和equals()⽅法来确定键值对的索引，当根据键获取值的

时候也会⽤到这两个⽅法。如果没有正确的实现这两个⽅法，两个不同的键可能会有相同的

hash值，因此，可能会被集合认为是相等的。⽽且，这两个⽅法也⽤来发现重复元素。所以

这两个⽅法的实现对HashMap的精确性和正确性是⾄关重要的。

 请问，Object作为HashMap的key的话，对Object有什么要求吗？

参考回答：

要求Object中hashcode不能变。

 请问 hashset 存的数是有序的吗？

参考回答：

Hashset是⽆序的。



1.2 | ⼆叉树

原⽂链接：<https://www.jianshu.com/p/0190985635eb>

 求⼆叉树的最⼤深度

参考回答：

```
```

```c++
```





 求⼆叉树的最⼩深度

参考回答：

1 int getMinDepth(TreeNode root){

2

if(root == null){

return 0;

3

4

}

5

return getMin(root);

6 }

7 int getMin(TreeNode root){

8

if(root == null){

9

return Integer.MAX\_VALUE;

10

}

11

if(root.left == null&&root.right == null){

12

return 1;

13

}

14

return Math.min(getMin(root.left),getMin(root.right)) + 1;

15 }

 求⼆叉树中节点的个数

参考回答：

1

2

3

4

5

6

7

8

9

int numOfTreeNode(TreeNode root){

if(root == null){

return 0;

}

int left = numOfTreeNode(root.left);

int right = numOfTreeNode(root.right);

return left + right + 1;

}

 求⼆叉树中叶⼦节点的个数

参考回答：

1

2

3

4

5

6

7

8

int numsOfNoChildNode(TreeNode root){

if(root == null){

return 0;

}

if(root.left==null&&root.right==null){

return 1;

}

return

numsOfNodeTreeNode(root.left)+numsOfNodeTreeNode(root.right);

9





10

}

 求⼆叉树中第k层节点的个数

参考回答：

1

2

int numsOfkLevelTreeNode(TreeNode root,int k){

if(root == null||k<1){

3

return 0;

4

}

5

if(k==1){

6

return 1;

7

}

8

int numsLeft = numsOfkLevelTreeNode(root.left,k-1);

int numsRight = numsOfkLevelTreeNode(root.right,k-1);

return numsLeft + numsRight;

9

10

11

}

 判断⼆叉树是否是平衡⼆叉树

参考回答：

1

2

boolean isBalanced(TreeNode node){

return maxDeath2(node)!=-1;

3

}

4

int maxDeath2(TreeNode node){

5

if(node == null){

6

return 0;

7

}

8

int left = maxDeath2(node.left);

9

int right = maxDeath2(node.right);

10

11

12

13

14

if(left==-1||right==-1||Math.abs(left-right)>1){

return -1;

}

return Math.max(left, right) + 1;

}

 判断⼆叉树是否是完全⼆叉树

参考回答：

1

2

boolean isCompleteTreeNode(TreeNode root){

if(root == null){

3

return false;

4

}

5

Queue<TreeNode> queue = new LinkedList<TreeNode>();

queue.add(root);

6

7

boolean result = true;

8

boolean hasNoChild = false;

while(!queue.isEmpty()){

TreeNode current = queue.remove();

9

10





11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

if(hasNoChild){

if(current.left!=null||current.right!=null){

result = false;

break;

}

}else{

if(current.left!=null&&current.right!=null){

queue.add(current.left);

queue.add(current.right);

}else if(current.left!=null&&current.right==null){

queue.add(current.left);

hasNoChild = true;

}else if(current.left==null&&current.right!=null){

result = false;

break;

}else{

hasNoChild = true;

}

}

}

return result;

}

 两个⼆叉树是否完全相同

参考回答：

1

2

boolean isSameTreeNode(TreeNode t1,TreeNode t2){

if(t1==null&&t2==null){

3

return true;

4

}

5

else if(t1==null||t2==null){

6

return false;

7

}

8

if(t1.val != t2.val){

9

return false;

10

11

12

13

14

15

}

boolean left = isSameTreeNode(t1.left,t2.left);

boolean right = isSameTreeNode(t1.right,t2.right);

return left&&right;

}

 两个⼆叉树是否互为镜像

参考回答：

1

boolean isMirror(TreeNode t1,TreeNode t2){





2

3

if(t1==null&&t2==null){

return true;

4

}

5

if(t1==null||t2==null){

6

return false;

7

}

8

if(t1.val != t2.val){

9

return false;

10

11

12

13

}

return isMirror(t1.left,t2.right)&&isMirror(t1.right,t2.left);

}

 翻转⼆叉树or镜像⼆叉树

参考回答：

1

2

TreeNode mirrorTreeNode(TreeNode root){

if(root == null){

3

return null;

4

}

5

TreeNode left = mirrorTreeNode(root.left);

6

TreeNode right = mirrorTreeNode(root.right);

7

root.left = right;

root.right = left;

return root;

8

9

10

}

 求两个⼆叉树的最低公共祖先节点

参考回答：

1

2

TreeNode getLastCommonParent(TreeNode root,TreeNode t1,TreeNode t2){

if(findNode(root.left,t1)){

3

if(findNode(root.right,t2)){

4

return root;

5

}else{

6

return getLastCommonParent(root.left,t1,t2);

7

}

8

}else{

9

if(findNode(root.left,t2)){

10

11

12

13

14

15

16

17

18

return root;

}else{

return getLastCommonParent(root.right,t1,t2)

}

}

}

// 查找节点node是否在当前 二叉树中

boolean findNode(TreeNode root,TreeNode node){

if(root == null || node == null){





19

20

21

22

23

24

25

26

27

28

29

return false;

}

if(root == node){

return true;

}

boolean found = findNode(root.left,node);

if(!found){

found = findNode(root.right,node);

}

return found;

}

 ⼆叉树的前序遍历

参考回答：

迭代解法

1

2

ArrayList<Integer> preOrder(TreeNode root){

Stack<TreeNode> stack = new Stack<TreeNode>();

3

ArrayList<Integer> list = new ArrayList<Integer>();

4

if(root == null){

return list;

5

6

}

7

stack.push(root);

while(!stack.empty()){

TreeNode node = stack.pop();

list.add(node.val);

if(node.right!=null){

stack.push(node.right);

}

8

9

10

11

12

13

14

15

16

17

18

19

20

if(node.left != null){

stack.push(node.left);

}

}

return list;

}

递归解法

1

2

ArrayList<Integer> preOrderReverse(TreeNode root){

ArrayList<Integer> result = new ArrayList<Integer>();

preOrder2(root,result);

3

4

return result;

5

6

}

7

void preOrder2(TreeNode root,ArrayList<Integer> result){

8

if(root == null){

9

return;

10

11

}

result.add(root.val);





12

13

14

preOrder2(root.left,result);

preOrder2(root.right,result);

}

 ⼆叉树的中序遍历

参考回答：

1

2

ArrayList<Integer> inOrder(TreeNode root){

ArrayList<Integer> list = new ArrayList<<Integer>();

Stack<TreeNode> stack = new Stack<TreeNode>();

TreeNode current = root;

while(current != null|| !stack.empty()){

while(current != null){

3

4

5

6

7

stack.add(current);

8

current = current.left;

9

}

10

11

12

13

14

15

16

17

18

current = stack.peek();

stack.pop();

list.add(current.val);

current = current.right;

}

return list;

}

 ⼆叉树的后序遍历

参考回答：

1

2

ArrayList<Integer> postOrder(TreeNode root){

ArrayList<Integer> list = new ArrayList<Integer>();

3

if(root == null){

return list;

4

5

}

6

list.addAll(postOrder(root.left));

list.addAll(postOrder(root.right));

list.add(root.val);

return list;

7

8

9

10

}

 前序遍历和后序遍历构造⼆叉树

参考回答：

1

2

3

4

TreeNode buildTreeNode(int[] preorder,int[] inorder){

if(preorder.length!=inorder.length){

return null;

}





5

return myBuildTree(inorder,0,inorder.length-

1,preorder,0,preorder.length-1);

6

7

}

TreeNode myBuildTree(int[] inorder,int instart,int inend,int[]

preorder,int prestart,int preend){

8

9

if(instart>inend){

return null;

10

11

12

}

TreeNode root = new TreeNode(preorder[prestart]);

int position =

findPosition(inorder,instart,inend,preorder[start]);

13

14

root.left = myBuildTree(inorder,instart,position-

1,preorder,prestart+1,prestart+position-instart);

root.right =

myBuildTree(inorder,position+1,inend,preorder,position-

inend+preend+1,preend);

15

16

17

18

19

20

21

22

23

24

25

return root;

}

int findPosition(int[] arr,int start,int end,int key){

int i;

for(i = start;i<=end;i++){

if(arr[i] == key){

return i;

}

}

return -1;

}

 在⼆叉树中插⼊节点

参考回答：

1

2

TreeNode insertNode(TreeNode root,TreeNode node){

if(root == node){

return node;

3

4

}

5

TreeNode tmp = new TreeNode();

tmp = root;

6

7

TreeNode last = null;

while(tmp!=null){

last = tmp;

8

9

10

11

12

13

14

15

16

17

18

if(tmp.val>node.val){

tmp = tmp.left;

}else{

tmp = tmp.right;

}

}

if(last!=null){

if(last.val>node.val){

last.left = node;





19

20

21

22

23

24

}else{

last.right = node;

}

}

return root;

}

 输⼊⼀个⼆叉树和⼀个整数，打印出⼆叉树中节点值的和等于输⼊整数所有的路径

参考回答：

1

2

void findPath(TreeNode r,int i){

if(root == null){

3

return;

4

}

5

Stack<Integer> stack = new Stack<Integer>();

int currentSum = 0;

6

7

findPath(r, i, stack, currentSum);

8

9

}

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

void findPath(TreeNode r,int i,Stack<Integer> stack,int currentSum){

currentSum+=r.val;

stack.push(r.val);

if(r.left==null&&r.right==null){

if(currentSum==i){

for(int path:stack){

System.out.println(path);

}

}

}

if(r.left!=null){

findPath(r.left, i, stack, currentSum);

}

if(r.right!=null){

findPath(r.right, i, stack, currentSum);

}

stack.pop();

}

 ⼆叉树的搜索区间

给定两个值 k1 和 k2（k1 < k2）和⼀个⼆叉查找树的根节点。找到树中所有值在 k1 到

k2 范围内的节点。即打印所有x (k1 <= x <= k2) 其中 x 是⼆叉查找树的中的节点值。返

回所有升序的节点值。

作者：IOExceptioner

链接：https://www.jianshu.com/p/0190985635eb

来源：简书

著作权归作者所有。商业转载请联系作者获得授权，⾮商业转载请注明出处。





参考回答：

ArrayList<Integer> result;

1

2

ArrayList<Integer> searchRange(TreeNode root,int k1,int k2){

3

result = new ArrayList<Integer>();

4

searchHelper(root,k1,k2);

5

return result;

6

}

7

void searchHelper(TreeNode root,int k1,int k2){

8

if(root == null){

9

return;

10

11

12

13

14

15

16

17

18

19

20

}

if(root.val>k1){

searchHelper(root.left,k1,k2);

}

if(root.val>=k1&&root.val<=k2){

result.add(root.val);

}

if(root.val<k2){

searchHelper(root.right,k1,k2);

}

}

 ⼆叉树的层次遍历

参考回答：

1

2

ArrayList<ArrayList<Integer>> levelOrder(TreeNode root){

ArrayList<ArrayList<Integer>> result = new

ArrayList<ArrayList<Integer>>();

3

4

if(root == null){

return result;

5

}

6

Queue<TreeNode> queue = new LinkedList<TreeNode>();

7

queue.offer(root);

8

while(!queue.isEmpty()){

9

int size = queue.size();

10

11

12

13

14

15

16

17

18

19

20

21

22

ArrayList<<Integer> level = new ArrayList<Integer>():

for(int i = 0;i < size ;i++){

TreeNode node = queue.poll();

level.add(node.val);

if(node.left != null){

queue.offer(node.left);

}

if(node.right != null){

queue.offer(node.right);

}

}

result.add(Level);

}





23

24

return result;

}

 ⼆叉树内两个节点的最⻓距离

⼆叉树中两个节点的最⻓距离可能有三种情况：

1.左⼦树的最⼤深度+右⼦树的最⼤深度为⼆叉树的最⻓距离

2.左⼦树中的最⻓距离即为⼆叉树的最⻓距离

3.右⼦树种的最⻓距离即为⼆叉树的最⻓距离

因此，递归求解即可

作者：IOExceptioner

链接：https://www.jianshu.com/p/0190985635eb

来源：简书

著作权归作者所有。商业转载请联系作者获得授权，⾮商业转载请注明出处。

参考回答：

1 private static class Result{

2

3

int maxDistance;

int maxDepth;

public Result() {

}

4

5

6

7

public Result(int maxDistance, int maxDepth) {

this.maxDistance = maxDistance;

this.maxDepth = maxDepth;

}

8

9

10

11 }

12

13

14

15

16

17

18

19

20

21

22

23

24

int getMaxDistance(TreeNode root){

return getMaxDistanceResult(root).maxDistance;

}

Result getMaxDistanceResult(TreeNode root){

if(root == null){

Result empty = new Result(0,-1);

return empty;

}

Result lmd = getMaxDistanceResult(root.left);

Result rmd = getMaxDistanceResult(root.right);

Result result = new Result();

result.maxDepth = Math.max(lmd.maxDepth,rmd.maxDepth) + 1;

result.maxDistance = Math.max(lmd.maxDepth +

rmd.maxDepth,Math.max(lmd.maxDistance,rmd.maxDistance));

25

26

return result;

}

 不同的⼆叉树

给出 n，问由 1...n 为节点组成的不同的⼆叉查找树有多少种？

参考回答：





1

2

int numTrees(int n ){

int[] counts = new int[n+2];

counts[0] = 1;

3

4

counts[1] = 1;

5

for(int i = 2;i<=n;i++){

for(int j = 0;j<i;j++){

6

7

counts[i] += counts[j] \* counts[i-j-1];

8

}

9

}

10

11

return counts[n];

}

 判断⼆叉树是否是合法的⼆叉查找树(BST)

⼀棵BST定义为：

节点的左⼦树中的值要严格⼩于该节点的值。

节点的右⼦树中的值要严格⼤于该节点的值。

左右⼦树也必须是⼆叉查找树。

⼀个节点的树也是⼆叉查找树。

参考回答：

1

2

public int lastVal = Integer.MAX\_VALUE;

public boolean firstNode = true;

3

public boolean isValidBST(TreeNode root) {

4

// write your code here

5

if(root==null){

6

return true;

7

}

8

if(!isValidBST(root.left)){

9

return false;

10

11

12

13

14

15

16

17

18

19

20

}

if(!firstNode&&lastVal >= root.val){

return false;

}

firstNode = false;

lastVal = root.val;

if (!isValidBST(root.right)) {

return false;

}

return true;

}

1.3 | 链表

 谈⼀谈，bucket如果⽤链表存储，它的缺点是什么？

参考回答：

①查找速度慢，因为查找时，需要循环链表访问





②如果进⾏频繁插⼊和删除操作，会导致速度很慢。

 有⼀个链表，奇数位升序偶数位降序，如何将链表变成升序？

参考回答：

1 public class

2 OddIncreaseEvenDecrease {

3

4

/\*\*

\* 按照奇偶位拆分成两个链表

5

\* @param head

6

\* @return

7

\*/

8

public static Node[] getLists(Node head){

Node head1 = null;

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

Node head2 = null;

Node cur1 = null;

Node cur2 = null;

int count = 1;//用来计数

while(head != null){

if(count % 2 == 1){

if(cur1 != null){

cur1.next = head;

cur1 = cur1.next;

}else{

cur1 = head;

head1 = cur1;

}

}else{

if(cur2 != null){

cur2.next = head;

cur2 = cur2.next;

}else{

cur2 = head;

head2 = cur2;

}

}

head = head.next;

count++;

}

//跳出循环，要让最后两个末尾元素的下一个都指向null

cur1.next = null;

cur2.next = null;

Node[] nodes = new Node[]{head1,

41 head2};

42

return nodes;

43

}





44

45

46

47

48

49

50

51

52

53

54

55

56

57

58

59

60

61

62

63

64

65

66

67

68

/\*\*

\* 反转链表

\* @param head

\* @return

\*/

public static Node reverseList(Node head){

Node pre = null;

Node next = null;

while(head != null){

next = head.next;

head.next = pre;

pre = head;

head = next;

}

return pre;

}

/\*\*

\* 合并两个有序链表

\* @param head1

\* @param head2

\* @return

\*/

public static Node CombineList(Node head1,

69 Node head2){

70

if(head1 == null || head2 == null){

return head1 != null ? head1 :

71

72 head2;

73

74

}

Node head = head1.value < head2.value ?

75 head1 : head2;

76

Node cur1 = head == head1 ? head1 :

77 head2;

78

Node cur2 = head == head1 ? head2 :

79 head1;

80

Node pre = null;

81

Node next = null;

82

while(cur1 != null && cur2 !=

83 null){

84

if(cur1.value <= cur2.value){//这里一定要有=，否则一旦cur1的value

和cur2的value相等的话，下面的pre.next会出现空指针异常

85

86

87

88

89

90

91

pre = cur1;

cur1 = cur1.next;

}else{

next = cur2.next;

pre.next = cur2;

cur2.next = cur1;

pre = cur2;





92

93

cur2 = next;

}

94

}

95

pre.next = cur1 == null ? cur2 : cur1;

96

97

return head;

98

}

99

100 }

 如何反转单链表

参考回答：

1 ListNode

2 reverseList(ListNode\* head) {

3

if(head == nullptr || head->next ==

4 nullptr)

5

6

7

8

9

return head;

ListNode\* p;

ListNode\* q;

ListNode\* r;

p = head;

10

q = head->next;

11

head->next = nullptr;//旧的头指针是新的尾指针 指向NULL

12

while(q){

13

r = q->next;//用来保存下一步要处理的指针

14

q->next = p;//p q 交替处理 进行反转单链表

15

p = q;

16

q = r;

17

}

18

head = p;//最后的q必定指向NULL，p就成了新链表的头指针

19

return head;

20 }

 现在有⼀个单向链表，谈⼀谈，如何判断链表中是否出现了环

参考回答：

单链表有环，是指单链表中某个节点的next指针域指向的是链表中在它之前的某⼀个节点，这

样在链表的尾部形成⼀个环形结构。

// 链表的节点结构如下 typedef st ruct node { int dat a; st ruct node \*next ; } NODE;

最常⽤⽅法：定义两个指针，同时从链表的头节点出发，⼀个指针⼀次⾛⼀步，另⼀个指针⼀

次⾛两步。如果⾛得快的指针追上了⾛得慢的指针，那么链表就是环形链表；如果⾛得快的指

针⾛到了链表的末尾（next指向 NULL）都没有追上第⼀个指针，那么链表就不是环形链表。





通过使⽤STL库中的map表进⾏映射。⾸先定义 map<NODE \*, int > m; 将⼀个 NODE \* 指针

映射成数组的下标，并赋值为⼀个 int 类型的数值。然后从链表的头指针开始往后遍历，每次

遇到⼀个指针p，就判断 m[p] 是否为0。如果为0，则将m[p]赋值为1，表示该节点第⼀次访

问；⽽如果m[p]的值为1，则说明这个节点已经被访问过⼀次了，于是就形成了环。

 随机链表的复制

参考回答：

1 public RandomListNode copyRandomList(RandomListNode head) {

2

3

4

if (head == null)

return null;

5

6

RandomListNode p = head;

7

8

// copy every node and insert to list

9

while (p != null) {

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

RandomListNode copy = new RandomListNode(p.label);

copy.next = p.next;

p.next = copy;

p = copy.next;

}

// copy random pointer for each new node

p = head;

while (p != null) {

if (p.random != null)

p.next.random = p.random.next;

p = p.next.next;

}

// break list to two

p = head;

RandomListNode newHead = head.next;

while (p != null) {

RandomListNode temp = p.next;

p.next = temp.next;

if (temp.next != null)

temp.next = temp.next.next;

p = p.next;

}





35

return newHead;

36 }

1.4 | 数组

 写⼀个算法，可以将⼀个⼆维数组顺时针旋转90度。

参考回答：

1 public void

2 rotate(int[][] matrix) {

3

int n = matrix.length;

4

for (int i = 0; i < n/2; i++) {

for (int j = i; j < n-1-i; j++)

5

6 {

7

8

int temp = matrix[i][j];

matrix[i][j] =

9 matrix[n-1-j][i];

matrix[n-1-j][i] =

11 matrix[n-1-i][n-1-j];

10

12

matrix[n-1-i][n-1-j] =

13 matrix[j][n-1-i];

14

matrix[j][n-1-i] = temp;

15

}

16

}

17 }

 ⼀个数组，除⼀个元素外其它都是两两相等，求那个元素?

参考回答：

1 public static int find1From2(int[] a){

2

int len = a.length, res = 0;

for(int i = 0; i < len; i++){

res= res ^ a[i];

}

3

4

5

6

return res;

7 }

 找出数组中和为S的⼀对组合，找出⼀组就⾏

参考回答：

1 public int[]

2 twoSum(int[] nums, int target) {





3

HashMap<Integer, Integer> map =

4 new HashMap<Integer, Integer>();

5

int[] a = new int[2];

6

map.put(nums[0], 0);

7

for (int i = 1; i < nums.length;

8 i++) {

9

if (map.containsKey(target - nums[i])) {

a[0] = map.get(target -

10

11 nums[i]);

12

13

14

15

16

a[1] = i;

return a;

} else {

map.put(nums[i], i);

}

17

}

18

return a;

19 }

 求⼀个数组中连续⼦向量的最⼤和

参考回答：

1 public int

2 maxSubArray(int[] nums) {

3

int sum = 0;

4

int maxSum = Integer.MIN\_VALUE;

if (nums == null || nums.length == 0) {

return sum;

5

6

7

}

8

for (int i = 0; i < nums.length;

9 i++) {

10

sum += nums[i];

11

maxSum = Math.max(maxSum, sum);

12

if (sum < 0) {

13

sum = 0;

14

}

15

}

16

return maxSum;

17 }

 寻找⼀数组中前K个最⼤的数

参考回答：





1 public int

2 findKthLargest(int[] nums, int k) {

3

if (k < 1 || nums == null) {

return

4

5 0;

6

7

8

}

return getKth(nums.length - k +1, nums, 0,

9 nums.length - 1);

10 }

11

12 public int

13 getKth(int k, int[] nums, int start, int end) {

14

15

16

17

18

19

20

21

22

int pivot = nums[end];

int left = start;

int right = end;

while (true) {

while

23 (nums[left] < pivot && left < right) {

24

25

26

27

left++;

}

while

28 (nums[right] >= pivot && right > left) {

29

30

31

32

right--;

}

if

33 (left == right) {

34

35

36

37

break;

}

swap(nums,

38 left, right);

39

40

41

42

}

swap(nums, left, end);





43

44

if (k == left + 1) {

return

45 pivot;

46

47

} else if (k < left + 1) {

return

48 getKth(k, nums, start, left - 1);

49

50

} else {

return

51 getKth(k, nums, left + 1, end);

52

}

53 }

54

55 public void

56 swap(int[] nums, int n1, int n2) {

57

int tmp = nums[n1];

nums[n1] = nums[n2];

nums[n2] = tmp;

58

59

60 }

1.5 | 排序

 ⽤Java写⼀个冒泡排序？

参考回答：

1 import

2 java.util.Comparator;

3 /\*\*

4

5

\* 排序器接口(策略模式: 将算法封装到具有共同接口的独立的类中使得它们可以相互替换)

\*/

6 public interface Sorter {

7

8

9

/\*\*

\*

\*/

10 public interface Sorter {

11

12

13

14

15

16

17

18

/\*\*

\* 排序

\* @param list 待排序的数组

\*/

public <T extends Comparable<T>> void sort(T[] list);

/\*\*

\* 排序

\* @param list 待排序的数组





19

\* @param comp 比较两个对象的比较器

20

\*/

21

public <T> void sort(T[] list, Comparator<T> comp);

22 }

23 import java.util.Comparator;

24 /\*\*

25

26

27

\* 冒泡排序

\*

\*/

28 public class BubbleSorter implements Sorter {

29

30

@Override

public <T extends Comparable<T>> void sort(T[]

31 list) {

32

33

boolean swapped = true;

for (int i = 1, len = list.length; i

34 < len && swapped; ++i) {

35

swapped =

36 false;

37

for (int j =

38 0; j < len - i; ++j) {

39

40 if (list[j].compareTo(list[j + 1]) > 0) {

41

42 T temp = list[j];

43

44 list[j] = list[j + 1];

45

46 list[j + 1] = temp;

47

48 swapped = true;

49

50 }

51

52

53

54

55

}

}

}

@Override

public <T> void sort(T[] list, Comparator<T>

56 comp) {

57

58

boolean swapped = true;

for (int i = 1, len = list.length; i

59 < len && swapped; ++i) {

60

swapped =





61 false;

62

for (int j =

63 0; j < len - i; ++j) {

64

65 if (comp.compare(list[j], list[j + 1]) > 0) {

66

67 T temp = list[j];

68

69 list[j] = list[j + 1];

70

71 list[j + 1] = temp;

72

73 swapped = true;

74

75 }

76

77

}

}

 介绍⼀下，排序都有哪⼏种⽅法？请列举出来

参考回答：

排序的⽅法有：插⼊排序（直接插⼊排序、希尔排序），交换排序（冒泡排序、快速排序），

选择排序（直接选择排序、堆排序），

归并排序，分配排序（箱排序、基数排序）

快速排序的伪代码。

/ /使⽤快速排序⽅法对a[ 0 :n- 1 ]排序

从a[ 0 :n- 1 ]中选择⼀个元素作为m i d d l e，该元素为⽀点

把余下的元素分割为两段left 和r i g h t，使得l e f t中的元素都⼩于等于⽀点，⽽right 中的

元素都⼤于等于⽀点

递归地使⽤快速排序⽅法对left 进⾏排序

递归地使⽤快速排序⽅法对right 进⾏排序

所得结果为l e f t + m i d d l e + r i g h t

 介绍⼀下，归并排序的原理是什么？

参考回答：

（1）归并排序是建⽴在归并操作上的⼀种有效的排序[算法](http://lib.csdn.net/base/datastructure)。该算法是采⽤分治法（Divide

and Conquer）的⼀个⾮常典型的应⽤。

（2）⾸先考虑下如何将将⼆个有序数列合并。这个⾮常简单，只要从⽐较⼆个数列的第⼀个

数，谁⼩就先取谁，取了后就在对应数列中删除这个数。然后再进⾏⽐较，如果有数列为空，

那直接将另⼀个数列的数据依次取出即可。





（3）解决了上⾯的合并有序数列问题，再来看归并排序，其的基本思路就是将数组分成⼆组

A，B，如果这⼆组组内的数据都是有序的，那么就可以很⽅便的将这⼆组数据进⾏排序。如

何让这⼆组组内数据有序了？

可以将A，B组各⾃再分成⼆组。依次类推，当分出来的⼩组只有⼀个数据时，可以认为这个

⼩组组内已经达到了有序，然后再合并相邻的⼆个⼩组就可以了。这样通过先递归的分解数

列，再合并数列就完成了归并排序。

 介绍⼀下，堆排序的原理是什么？

参考回答：

堆排序就是把最⼤堆堆顶的最⼤数取出，将剩余的堆继续调整为最⼤堆，再次将堆顶的最⼤数

取出，这个过程持续到剩余数只有⼀个时结束。在堆中定义以下⼏种操作：

（1）最⼤堆调整（Max-Heapify）：将堆的末端⼦节点作调整，使得⼦节点永远⼩于⽗节

点。

（2）创建最⼤堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最⼤堆。

（3）堆排序（Heap-Sort）：移除位在第⼀个数据的根节点，并做最⼤堆调整的递归运算

 谈⼀谈，如何得到⼀个数据流中的中位数？

参考回答：

数据是从⼀个数据流中读出来的，数据的数⽬随着时间的变化⽽增加。如果⽤⼀个数据容器来

保存从流中读出来的数据，当有新的数据流中读出来时，这些数据就插⼊到数据容器中。

数组是最简单的容器。如果数组没有排序，可以⽤ Part it ion 函数找出数组中的中位数。在没

有排序的数组中插⼊⼀个数字和找出中位数的时间复杂度是 O(1)和 O(n)。

我们还可以往数组⾥插⼊新数据时让数组保持排序，这是由于可能要移动 O(n)个数，因此需

要 O(n)时间才能完成插⼊操作。在已经排好序的数组中找出中位数是⼀个简单的操作，只需

要 O(1)时间即可完成。

排序的链表时另外⼀个选择。我们需要 O(n)时间才能在链表中找到合适的位置插⼊新的数

据。如果定义两个指针指向链表的中间结点（如果链表的结点数⽬是奇数，那么这两个指针指





向同⼀个结点），那么可以在 O（1）时间得出中位数。此时时间效率与及基于排序的数组的

时间效率⼀样。

如果能够保证数据容器左边的数据都⼩于右边的数据，这样即使左、右两边内部的数据没有排

序，也可以根据左边最⼤的数及右边最⼩的数得到中位数。如何快速从⼀个容器中找出最⼤

数？⽤最⼤堆实现这个数据容器，因为位于堆顶的就是最⼤的数据。同样，也可以快速从最⼩

堆中找出最⼩数。

因此可以⽤如下思路来解决这个问题：⽤⼀个最⼤堆实现左边的数据容器，⽤最⼩堆实现右边

的数据容器。往堆中插⼊⼀个数据的时间效率是 O(logn)。由于只需 O(1)时间就可以得到位

于堆顶的数据，因此得到中位数的时间效率是 O(1)。

 你知道哪些排序算法，这些算法的时间复杂度分别是多少，解释⼀下快排？

参考回答：

快排：快速排序有两个⽅向，左边的i下标⼀直往右⾛（当条件a[i] <= a[center\_index]时），

其中center\_index是中枢元素的数组下标，⼀般取为数组第0个元素。

⽽右边的j下标⼀直往左⾛（当a[j] > a[center\_index]时）。

如果i和j都⾛不动了，i <= j, 交换a[i]和a[j],重复上⾯的过程，直到i>j。交换a[j]和

a[center\_index]，完成⼀趟快速排序。

1.6 | 堆与栈

 请你解释⼀下，内存中的栈(stack)、堆(heap) 和静态区(static area) 的⽤法。

参考回答：

通常我们定义⼀个基本数据类型的变量，⼀个对象的引⽤，还有就是函数调⽤的现场保存都使

⽤内存中的栈空间；⽽通过new关键字和构造器创建的对象放在堆空间；程序中的字⾯量

（literal）如直接书写的100、"hello"和常量都是放在静态区中。栈空间操作起来最快但是栈

很⼩，通常⼤量的对象都是放在堆空间，理论上整个内存没有被其他进程使⽤的空间甚⾄硬盘

上的虚拟内存都可以被当成堆空间来使⽤。

St ring str = new String("hello");

上⾯的语句中变量str放在栈上，⽤new创建出来的字符串对象放在堆上，⽽"hello"这个字⾯

量放在静态区。





 说⼀说，heap和stack有什么区别。

参考回答：

（1）Java的堆是⼀个运⾏时数据区，类的对象从中分配空间。通过⽐如：new等指令建⽴，

不需要代码显式的释放，由垃圾回收来负责。

优点：可以动态地分配内存⼤⼩，垃圾收集器会⾃动回收垃圾数据。

缺点：由于其优点，所以存取速度较慢。

（2）栈：

其数据项的插⼊和删除都只能在称为栈顶的⼀端完成，后进先出。栈中存放⼀些基本类型的

变量 和 对象句柄。

优点：读取数度⽐堆要快，仅次于寄存器，栈数据可以共享。

缺点：⽐堆缺乏灵活性，存在栈中的数据⼤⼩与⽣存期必须是确定的。

举例：

String是⼀个特殊的包装类数据。可以⽤：

St ring str = new String("geek");

St ring str = "geek";

两种的形式来创建，第⼀种是⽤new()来新建对象的，它会在存放于堆中。每调⽤⼀次就会创

建⼀个新的对象。⽽第⼆种是先在栈中创建⼀个对String类的对象引⽤变量str，然后查找栈

中有没有存放"geek"，如果没有，则将"geek"存放进栈，并令str指向"abc"，如果已经

有"geek"则直接令str指向"geek"。

 最⼩的k个数

输⼊整数数组 arr ，找出其中最⼩的 k 个数。例如，输⼊4、5、1、6、2、7、3、8这8个

数字，则最⼩的4个数字是1、2、3、4。

示例 1：

输⼊：arr = [3,2,1], k = 2

输出：[1,2] 或者 [2,1]

示例 2：

输⼊：arr = [0,1,2,1], k = 1

输出：[0]

限制：

0 <= k <= arr.length <= 10000

0 <= arr[i] <= 10000

来源：⼒扣（LeetCode）

链接：<https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof>

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：





⼤根堆(前 K ⼩) / ⼩根堆（前 K ⼤),Java中有现成的 PriorityQueue，实现起来最简单：

O(NlogK)O(NlogK)

本题是求前 K ⼩，因此⽤⼀个容量为 K 的⼤根堆，每次 poll 出最⼤的数，那堆中保留的就是

前 K ⼩啦（注意不是⼩根堆！⼩根堆的话需要把全部的元素都⼊堆，那是 O(NlogN)O(NlogN)

，就不是 O(NlogK)O(NlogK)啦～～）

这个⽅法⽐快排慢，但是因为 Java 中提供了现成的 PriorityQueue（默认⼩根堆），所以实

现起来最简单，没⼏⾏代码～

1 // 保持堆的大小为K，然后遍历数组中的数字，遍历的时候做如下判断：

2 // 1. 若目前堆的大小小于K，将当前数字放入堆中。

3 // 2. 否则判断当前数字与大根堆堆顶元素的大小关系，如果当前数字比大根堆堆顶还大，这个

数就直接跳过；

4 //

反之如果当前数字比大根堆堆顶小，先poll掉堆顶，再将该数字放入堆中。

5 class Solution {

6

7

public int[] getLeastNumbers(int[] arr, int k) {

if (k == 0 || arr.length == 0) {

8

return new int[0];

9

}

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29 }

// 默认是小根堆，实现大根堆需要重写一下比较器。

Queue<Integer> pq = new PriorityQueue<>((v1, v2) -> v2 - v1);

for (int num: arr) {

if (pq.size() < k) {

pq.offer(num);

} else if (num < pq.peek()) {

pq.poll();

pq.offer(num);

}

}

// 返回堆中的元素

int[] res = new int[pq.size()];

int idx = 0;

for(int num: pq) {

res[idx++] = num;

}

return res;

}

301 作者：sweetiee

32 链接：https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-

lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou/

33 来源：力扣（LeetCode）

34 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

 滑动窗⼝最⼤值

给你⼀个整数数组 nums，有⼀个⼤⼩为 k 的滑动窗⼝从数组的最左侧移动到数组的最右

侧。你只可以看到在滑动窗⼝内的 k 个数字。滑动窗⼝每次只向右移动⼀位。





返回滑动窗⼝中的最⼤值。

示例 1：

输⼊：nums = [1,3,-1,-3,5,3,6,7], k = 3

输出：[3,3,5,5,6,7]

解释：

滑动窗⼝的位置

最⼤值

\-----

\---------------

[1 3 -1] -3 5 3 6 7

1 [3 -1 -3] 5 3 6 7

1 3 [-1 -3 5] 3 6 7

1 3 -1 [-3 5 3] 6 7

1 3 -1 -3 [5 3 6] 7

1 3 -1 -3 5 [3 6 7]

示例 2：

3

3

5

5

6

7

输⼊：nums = [1], k = 1

输出：[1]

示例 3：

输⼊：nums = [1,-1], k = 1

输出：[1,-1]

示例 4：

输⼊：nums = [9,11], k = 2

输出：[11]

示例 5：

输⼊：nums = [4,-2], k = 2

输出：[4]

提示：

1 <= nums.length <= 105

-104 <= nums[i] <= 104

1 <= k <= nums.length

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/sliding-window-maximum

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

最⼤堆(优先队列)

我们可以采⽤最⼤堆的数据结构来保存元素，堆顶元素即为当前堆的最⼤值，并判断当前堆顶

元素这是否在窗⼝中，在则直接返回，不在则删除堆顶元素并调整堆。





我们以nums = [1,3,-1,-3,5,3,6,7], k = 3为例来模拟堆的过程。









上述如何创建堆和调整堆暂不讨论,感兴趣可⾃⾏百度。在Java中的优先队列(PriorityQueue)

就是堆的数据结构。代码如下：

1 public int[] maxSlidingWindow(int[] nums, int k) {

2

3

4

int n = nums.length;

//这里我们传入了一个比较器，当两者的值相同时，比较下标的位置，下标大的在前面。

PriorityQueue<int[]> queue = new PriorityQueue<>((p1, p2) -> p1[0] !=

p2[0] ? p2[0] - p1[0] : p2[1] - p1[1]);

//初始化前K的元素到堆中

5

6

7

for (int i = 0; i < k; i++) {

queue.offer(new int[]{nums[i], i});





8

9

}

//有n-k+1个

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24 }

int[] ans = new int[n - k + 1];

//将第一次答案加入数据

ans[0] = queue.peek()[0];

for (int i = k; i < n; i++) {

//将新元素加入优先队列

queue.offer(new int[]{nums[i], i});

//循环判断当前队首是否在窗口中，窗口的左边界为i-k

while (queue.peek()[1] <= i - k) {

queue.poll();

}

//在窗口中直接赋值即可

ans[i - k + 1] = queue.peek()[0];

}

return ans;

256 作者：jiang-hui-4

27 链接：https://leetcode-cn.com/problems/sliding-window-maximum/solution/you-

xian-dui-lie-zui-da-dui-dan-diao-dui-dbn9/

28 来源：力扣（LeetCode）

29 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

 丑数

我们把只包含质因⼦ 2、3 和 5 的数称作丑数（Ugly Number）。求按从⼩到⼤的顺序的

第 n 个丑数。

示例:

输⼊: n = 10

输出: 12

解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。

说明:

1 是丑数。

n 不超过1690。

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/chou-shu-lcof

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

解题思路

跟⾯试题 17.09. 第k个数⼀样的做法，任何丑数乘以2、3、5，其结果也是丑数（证明略），

我们可以利⽤⼩根堆，然后1作为第⼀个丑数，每次从⼩根堆弹出最⼩的丑数，然后记录已弹





出丑数的个数，如果count>=n,返回当前弹出的元素，否则继续乘以2、3、5，（注意：放⼊

堆⾥的元素需要排除重复值）。

代码

1 class Solution {

2

3

private int[] uglyNumber = {2,3,5};

public int nthUglyNumber(int n) {

4

Set<Long> set = new HashSet<>();

5

//创建小根堆，每次出堆的都是最小值

6

PriorityQueue<Long> queue = new PriorityQueue<>();

7

queue.add(1L);

8

//记录出堆的个数，出堆的元素完全按照从小到大排序

9

int count = 0;

10

11

123

14

15

16

17

18

19

20

21

22

23

24

25

26

27 }

while (! queue.isEmpty()){

long cut = queue.poll();

//如果出堆的个数>=n,当前cut就是第n个丑数

if(++count >= n){

return (int) cut;

}

for(int num : uglyNumber){

//排除重复的数字

if(! set.contains(num \* cut)){

queue.add(num \* cut);

set.add(num \* cut);

}

}

}

return -1;

}

289 作者：YanShaoJiangHu

30 链接：https://leetcode-cn.com/problems/chou-shu-lcof/solution/li-yong-xiao-

gen-dui-wan-mei-jie-jue-by-yanshaojia/

31 来源：力扣（LeetCode）

32 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

 前K个⾼频元素

给定⼀个⾮空的整数数组，返回其中出现频率前 k ⾼的元素。

示例 1:

输⼊: nums = [1,1,1,2,2,3], k = 2

输出: [1,2]

示例 2:

输⼊: nums = [1], k = 1

输出: [1]





提示：

你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。

你的算法的时间复杂度必须优于 O(n log n) , n 是数组的⼤⼩。

题⽬数据保证答案唯⼀，换句话说，数组中前 k 个⾼频元素的集合是唯⼀的。

你可以按任意顺序返回答案。

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/top-k-frequent-elements

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

最⼩堆

题⽬最终需要返回的是前 kk 个频率最⼤的元素，可以想到借助堆这种数据结构，对于 kk 频

率之后的元素不⽤再去处理，进⼀步优化时间复杂度。

具体操作为：

借助 哈希表 来建⽴数字和其出现次数的映射，遍历⼀遍数组统计元素的频率

维护⼀个元素数⽬为 kk 的最⼩堆

每次都将新的元素与堆顶元素（堆中频率最⼩的元素）进⾏⽐较

如果新的元素的频率⽐堆顶端的元素⼤，则弹出堆顶端的元素，将新的元素添加进堆中

最终，堆中的 kk 个元素即为前 kk 个⾼频元素

[https://pic.leetcode-cn.com/b548a3796066fa7072baa2b1e06e0d54641a7913d87c88c](https://pic.leetcode-cn.com/b548a3796066fa7072baa2b1e06e0d54641a7913d87c88c61d73b6b9ad0e90db-file_1561712388100)

[61d73b6b9ad0e90db-ﬁle_1561712388100](https://pic.leetcode-cn.com/b548a3796066fa7072baa2b1e06e0d54641a7913d87c88c61d73b6b9ad0e90db-file_1561712388100)





代码如下：

1 class Solution {

2

3

public List<Integer> topKFrequent(int[] nums, int k) {

// 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值

4

HashMap<Integer,Integer> map = new HashMap();

5

for(int num : nums){

6

if (map.containsKey(num)) {

7

map.put(num, map.get(num) + 1);

8

} else {

9

map.put(num, 1);

10

11

12

13

}

}

// 遍历map，用最小堆保存频率最大的k个元素

PriorityQueue<Integer> pq = new PriorityQueue<>(new

Comparator<Integer>() {

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34 }

@Override

public int compare(Integer a, Integer b) {

return map.get(a) - map.get(b);

}

});

for (Integer key : map.keySet()) {

if (pq.size() < k) {

pq.add(key);

} else if (map.get(key) > map.get(pq.peek())) {

pq.remove();

pq.add(key);

}

}

// 取出最小堆中的元素

List<Integer> res = new ArrayList<>();

while (!pq.isEmpty()) {

res.add(pq.remove());

}

return res;

}

复杂度分析

时间复杂度：O(nlogk)O(nlogk)，nn 表示数组的⻓度。⾸先，遍历⼀遍数组统计元素的频

率，这⼀系列操作的时间复杂度是 O(n)O(n)；接着，遍历⽤于存储元素频率的 map，如果元

素的频率⼤于最⼩堆中顶部的元素，则将顶部的元素删除并将该元素加⼊堆中，这⾥维护堆的

数⽬是 kk，所以这⼀系列操作的时间复杂度是 O(nlogk)O(nlogk) 的；因此，总的时间复杂度

是 O(nlogk)O(nlogk)。

空间复杂度：O(n)O(n)，最坏情况下（每个元素都不同），map 需要存储 nn 个键值对，优先

队列需要存储 kk 个元素，因此，空间复杂度是 O(n)O(n)。

作者：MisterBooo

[链接：](https://leetcode-cn.com/problems/top-k-frequent-elements/solution/leetcode-di-347-hao-wen-ti-qian-k-ge-gao-pin-yuan-/)[https://leetcode-cn.com/problems/top-k-frequent-elements/solution/leetcode](https://leetcode-cn.com/problems/top-k-frequent-elements/solution/leetcode-di-347-hao-wen-ti-qian-k-ge-gao-pin-yuan-/)

[-di-347-hao-wen-ti-qian-k-ge-gao-pin-yuan-/](https://leetcode-cn.com/problems/top-k-frequent-elements/solution/leetcode-di-347-hao-wen-ti-qian-k-ge-gao-pin-yuan-/)





来源：⼒扣（LeetCode）

著作权归作者所有。商业转载请联系作者获得授权，⾮商业转载请注明出处。

 有效的括号

给定⼀个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满⾜：

左括号必须⽤相同类型的右括号闭合。

左括号必须以正确的顺序闭合。

示例 1：

输⼊：s = "()"

输出：true

示例 2：

输⼊：s = "()[]{}"

输出：true

示例 3：

输⼊：s = "(]"

输出：false

示例 4：

输⼊：s = "([)]"

输出：false

示例 5：

输⼊：s = "{[]}"

输出：true

提示：

1 <= s.lengt h <= 104

s 仅由括号 '()[]{}' 组成

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/valid-parentheses

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

解题思路：

算法原理

栈先⼊后出特点恰好与本题括号排序特点⼀致，即若遇到左括号⼊栈，遇到右括号时将对应栈

顶左括号出栈，则遍历完所有括号后 stack 仍然为空；





建⽴哈希表 dic 构建左右括号对应关系：keykey 左括号，valuevalue 右括号；这样查询 22

个括号是否对应只需 O(1)O(1) 时间复杂度；建⽴栈 stack，遍历字符串 s 并按照算法流程⼀

⼀判断。

算法流程

如果 c 是左括号，则⼊栈 pushpush；

否则通过哈希表判断括号对应关系，若 stack 栈顶出栈括号 stack.pop() 与当前遍历括号 c

不对应，则提前返回 falsefalse。

提前返回 falsefalse

提前返回优点： 在迭代过程中，提前发现不符合的括号并且返回，提升算法效率。

解决边界问题：

栈 stack 为空： 此时 stack.pop() 操作会报错；因此，我们采⽤⼀个取巧⽅法，给 stack 赋

初值 ?? ，并在哈希表 dic 中建⽴ key: '?'，value:'?'key:

′

?

′

，value:

′

?

′

的对应关系予以配合。此时当 stack 为空且 c 为右括号时，可以正常提前返回 falsefalse；

字符串 s 以左括号结尾： 此情况下可以正常遍历完整个 s，但 stack 中遗留未出栈的左括

号；因此，最后需返回 len(stack) == 1，以判断是否是有效的括号组合。

复杂度分析

时间复杂度 O(N)O(N)：正确的括号组合需要遍历 11 遍 s；

空间复杂度 O(N)O(N)：哈希表和栈使⽤线性的空间⼤⼩。









代码：

1 class Solution {

2

private static final Map<Character,Character> map = new

HashMap<Character,Character>(){{

3

4

5

6

7

put('{','}'); put('[',']'); put('(',')'); put('?','?');

}};

public boolean isValid(String s) {

if(s.length() > 0 && !map.containsKey(s.charAt(0))) return false;

LinkedList<Character> stack = new LinkedList<Character>() {{

add('?'); }};

8

9

for(Character c : s.toCharArray()){

if(map.containsKey(c)) stack.addLast(c);

10

11

12

13

else if(map.get(stack.removeLast()) != c) return false;

}

return stack.size() == 1;

}

14 }

156 作者：jyd

17 链接：https://leetcode-cn.com/problems/valid-parentheses/solution/valid-

parentheses-fu-zhu-zhan-fa-by-jin407891080/

18 来源：力扣（LeetCode）

19 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

 最⼩栈

设计⼀个⽀持 push ，pop ，top 操作，并能在常数时间内检索到最⼩元素的栈。

push(x) —— 将元素 x 推⼊栈中。

pop() —— 删除栈顶的元素。

top() —— 获取栈顶元素。

getMin() —— 检索栈中的最⼩元素。





示例:

输⼊：

["MinStack","push","push","push","getMin","pop","top","getMin"]

[[],[-2],[0],[-3],[],[],[],[]]

输出：

[null,null,null,null,-3,null,0,-2]

解释：

MinSt ack minSt ack = new MinStack();

minStack.push(-2);

minStack.push(0);

minStack.push(-3);

minStack.getMin(); --> 返回 -3.

minStack.pop();

minSt ack.t op();

--> 返回 0.

minStack.getMin(); --> 返回 -2.

提示：

pop、top 和 get Min 操作总是在 ⾮空栈 上调⽤。

来源：⼒扣（LeetCode）

链接：<https://leetcode-cn.com/problems/min-stack>

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

这道题的思想很简单：“以空间换时间”，使⽤辅助栈是常⻅的做法。

思路分析：

在代码实现的时候有两种⽅式：

1、辅助栈和数据栈同步

特点：编码简单，不⽤考虑⼀些边界情况，就有⼀点不好：辅助栈可能会存⼀些“不必要”的元

素。

2、辅助栈和数据栈不同步

特点：由“辅助栈和数据栈同步”的思想，我们知道，当数据栈进来的数越来越⼤的时候，我们

要在辅助栈顶放置和当前辅助栈顶⼀样的元素，这样做有点“浪费”。基于这⼀点，我们做⼀

些“优化”，但是在编码上就要注意⼀些边界条件。

（1）辅助栈为空的时候，必须放⼊新进来的数；





（2）新来的数⼩于或者等于辅助栈栈顶元素的时候，才放⼊，特别注意这⾥“等于”要考虑进

去，因为出栈的时候，连续的、相等的并且是最⼩值的元素要同步出栈；

（3）出栈的时候，辅助栈的栈顶元素等于数据栈的栈顶元素，才出栈。

总结⼀下：出栈时，最⼩值出栈才同步；⼊栈时，最⼩值⼊栈才同步。

对⽐：个⼈觉得“同步栈”的⽅式更好⼀些，因为思路清楚，因为所有操作都同步进⾏，所以调

试代码、定位问题也简单。“不同步栈”，虽然减少了⼀些空间，但是在“出栈”、“⼊栈”的时

候还要做判断，也有性能上的消耗。

⽅法⼀：辅助栈和数据栈同步

参考代码 1：

1 import java.util.Stack;

23 public class MinStack {

45

6

// 数据栈

private Stack<Integer> data;

7

// 辅助栈

8

private Stack<Integer> helper;

190

11

12

13

14

15

16

178

12 90

21

22

23

24

25

26

27

28

23 90

31

32

33

34

35

36

378

39

40

41

42

/\*\*

\* initialize your data structure here.

\*/

public MinStack() {

data = new Stack<>();

helper = new Stack<>();

}

// 思路 1：数据栈和辅助栈在任何时候都同步

public void push(int x) {

// 数据栈和辅助栈一定会增加元素

data.add(x);

if (helper.isEmpty() || helper.peek() >= x) {

helper.add(x);

} else {

helper.add(helper.peek());

}

}

public void pop() {

// 两个栈都得 pop

if (!data.isEmpty()) {

helper.pop();

data.pop();

}

}

public int top() {

if(!data.isEmpty()){

return data.peek();

}

throw new RuntimeException("栈中元素为空，此操作非法");





43

}

445

public int getMin() {

46

if(!helper.isEmpty()){

47

return helper.peek();

48

}

49

throw new RuntimeException("栈中元素为空，此操作非法");

50

}

51 }

复杂度分析：

时间复杂度：O(1)O(1)，“出栈”、“⼊栈”、“查看栈顶元素”的操作不论数据规模多⼤，都只

是有限个步骤，因此时间复杂度是：O(1)O(1)。

空间复杂度：O(N)O(N)，这⾥ NN 是读出的数据的个数。

⽅法⼆：辅助栈和数据栈不同步

参考代码 2：

1 import java.util.Stack;

23 public class MinStack {

45

6

//

数据栈

private Stack<Integer> data;

7

// 辅助栈

8

private Stack<Integer> helper;

190

11

12

13

14

15

16

178

19

20

/\*\*

\* initialize your data structure here.

\*/

public MinStack() {

data = new Stack<>();

helper = new Stack<>();

}

//

思路 ：辅助栈和数据栈不同步

2

// 关键 1：辅助栈的元素空的时候，必须放入新进来的数

// 关键 2：新来的数小于或者等于辅助栈栈顶元素的时候，才放入（特别注意这里等于要

考虑进去）

// 关键 3：出栈的时候，辅助栈的栈顶元素等于数据栈的栈顶元素，才出栈，即"出栈保

持同步"就可以了

21

223

24

25

26

27

28

29

30

312

public void push(int x) {

// 辅助栈在必要的时候才增加

data.add(x);

// 关键 1 和 关键 2

if (helper.isEmpty() || helper.peek() >= x) {

helper.add(x);

}

}

public void pop() {





33

34

35

// 关键 3：data 一定得 pop()

if (!data.isEmpty()) {

// 注意：声明成 int 类型，这里完成了自动拆箱，从 Integer 转成了

int，因此下面的比较可以使用 "==" 运算符

36

37

// 参考资料：https://www.cnblogs.com/GuoYaxiang/p/6931264.html

// 如果把 top 变量声明成 Integer 类型，下面的比较就得使用 equals 方

法

38

39

40

41

42

43

445

46

47

48

49

50

512

53

54

55

56

57

int top = data.pop();

if(top == helper.peek()){

helper.pop();

}

}

}

public int top() {

if(!data.isEmpty()){

return data.peek();

}

throw new RuntimeException("栈中元素为空，此操作非法");

}

public int getMin() {

if(!helper.isEmpty()){

return helper.peek();

}

throw new RuntimeException("栈中元素为空，此操作非法");

}

589 }

复杂度分析：

时间复杂度：O(1)O(1)，“出栈”、“⼊栈”、“查看栈顶元素”的操作不论数据规模多⼤，都只

有有限个步骤，因此时间复杂度是：O(1)O(1)。

空间复杂度：O(N)O(N)，这⾥ NN 是读出的数据的个数。

作者：liweiwei1419

[链接：](https://leetcode-cn.com/problems/min-stack/solution/shi-yong-fu-zhu-zhan-tong-bu-he-bu-tong-bu-python-/)[https://leetcode-cn.com/problems/min-stack/solution/shi-yong-fu-zhu-zhan-t](https://leetcode-cn.com/problems/min-stack/solution/shi-yong-fu-zhu-zhan-tong-bu-he-bu-tong-bu-python-/)

[ong-bu-he-bu-tong-bu-python-/](https://leetcode-cn.com/problems/min-stack/solution/shi-yong-fu-zhu-zhan-tong-bu-he-bu-tong-bu-python-/)

来源：⼒扣（LeetCode）

著作权归作者所有。商业转载请联系作者获得授权，⾮商业转载请注明出处。

 柱状图中最⼤的矩形

给定 n 个⾮负整数，⽤来表示柱状图中各个柱⼦的⾼度。每个柱⼦彼此相邻，且宽度为 1

。

求在该柱状图中，能够勾勒出来的矩形的最⼤⾯积。





以上是柱状图的示例，其中每个柱⼦的宽度为 1，给定的⾼度为 [2,1,5,6,2,3]。

图中阴影部分为所能勾勒出的最⼤矩形⾯积，其⾯积为 10 个单位。

示例:

输⼊: [2,1,5,6,2,3]

输出: 10

来源：⼒扣（LeetCode）

链接：<https://leetcode-cn.com/problems/largest-rectangle-in-histogram>

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

思路：

⾸先，要想找到第 i 位置最⼤⾯积是什么？

是以i 为中⼼，向左找第⼀个⼩于 heights[i] 的位置 left\_i；向右找第⼀个⼩于于 heights[i] 的

位置 right\_i，即最⼤⾯积为 heights[i] \* (right \_i - lef t \_i -1)，如下图所示：





所以，我们的问题就变成如何找 right \_i 和 lef t \_i？

最简单的思路就是，就是暴⼒法，直接分别在 i 左右移动。

但是，这是⼀个时间复杂度为 O(n^2)O(n

2

)，超时。

接下来想办法优化。

思路⼀：

当我们找 i 左边第⼀个⼩于 heights[i] 如果 heights[i-1] >= heights[i] 其实就是和 heights[i-

1] 左边第⼀个⼩于 heights[i-1] ⼀样。依次类推，右边同理。

思路⼆：栈

利⽤单调栈

维护⼀个单调递增的栈，就可以找到 lef t \_i 和 right \_i。

代码：

思路⼀：

1 class Solution {

2

3

public int largestRectangleArea(int[] heights) {

if (heights == null || heights.length == 0) return 0;

int n = heights.length;

4

5

int[] left\_i = new int[n];

6

int[] right\_i = new int[n];

left\_i[0] = -1;

7

8

right\_i[n - 1] = n;

9

int res = 0;

10

11

12

for (int i = 1; i < n; i++) {

int tmp = i - 1;

while (tmp >= 0 && heights[tmp] >= heights[i]) tmp =

left\_i[tmp];

left\_i[i] = tmp;

13

14

15

16

17

}

for (int i = n - 2; i >= 0; i--) {

int tmp = i + 1;

while (tmp < n && heights[tmp] >= heights[i]) tmp =

right\_i[tmp];

right\_i[i] = tmp;

18

19

20

}

for (int i = 0; i < n; i++) res = Math.max(res, (right\_i[i] -

left\_i[i] - 1) \* heights[i]);





21

return res;

22

}

23 }

思路⼆：

1 class Solution {

2

3

4

5

6

public int largestRectangleArea(int[] heights) {

int res = 0;

Deque<Integer> stack = new ArrayDeque<>();

int[] new\_heights = new int[heights.length + 2];

for (int i = 1; i < heights.length + 1; i++) new\_heights[i] =

heights[i - 1];

7

8

//System.out.println(Arrays.toString(new\_heights));

for (int i = 0; i < new\_heights.length; i++) {

//System.out.println(stack.toString());

9

10

while (!stack.isEmpty() && new\_heights[stack.peek()] >

new\_heights[i]) {

11

12

int cur = stack.pop();

res = Math.max(res, (i - stack.peek() - 1) \*

new\_heights[cur]);

13

}

14

stack.push(i);

15

}

16

return res;

17

}

18 }

12 90

21

powcai

作者：

链接：https://leetcode-cn.com/problems/largest-rectangle-in-

histogram/solution/zhao-liang-bian-di-yi-ge-xiao-yu-ta-de-zhi-by-powc/

来源：力扣（LeetCode）

22

23

著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

1.7 | ⾼级算法

 请你讲讲LRU算法的实现原理？

参考回答：

①LRU（Least recently used，最近最少使⽤）算法根据数据的历史访问记录来进⾏淘汰数

据，其核⼼思想是“如果数据最近被访问过，那么将来被访问的⼏率也很⾼”，反过来说“如果

数据最近这段时间⼀直都没有访问,那么将来被访问的概率也会很低”，两种理解是⼀样的；常

⽤于⻚⾯置换算法，为虚拟⻚式存储管理服务。





②达到这样⼀种情形的算法是最理想的：每次调换出的⻚⾯是所有内存⻚⾯中最迟将被使⽤

的；这可以最⼤限度的推迟⻚⾯调换，这种算法，被称为理想⻚⾯置换算法。可惜的是，这种

算法是⽆法实现的。

为了尽量减少与理想算法的差距，产⽣了各种精妙的算法，最近最少使⽤⻚⾯置换算法便是其

中⼀个。LRU 算法的提出，是基于这样⼀个事实：在前⾯⼏条指令中使⽤频繁的⻚⾯很可能

在后⾯的⼏条指令中频繁使⽤。反过来说，已经很久没有使⽤的⻚⾯很可能在未来较⻓的⼀段

时间内不会被⽤到 。这个，就是著名的局部性原理——⽐内存速度还要快的cache，也是基于

同样的原理运⾏的。因此，我们只需要在每次调换时，找到最近最少使⽤的那个⻚⾯调出内

存。

算法实现的关键

命中率：

当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致 LRU 命中率急

剧下降，缓存污染情况⽐较严重。

复杂度：

实现起来较为简单。

存储成本：

⼏乎没有空间上浪费。

代价：

命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部。

 为什么要设计 后缀表达式，有什么好处？

参考回答：

后缀表达式⼜叫逆波兰表达式，逆波兰记法不需要括号来标识操作符的优先级。

 请你设计⼀个算法，⽤来压缩⼀段URL？

参考回答：

该算法主要使⽤MD5 算法对原始链接进⾏加密（这⾥使⽤的MD5 加密后的字符串⻓度为

32 位），然后对加密后的字符串进⾏处理以得到短链接的地址。

 谈⼀谈，id全局唯⼀且⾃增，如何实现？

参考回答：

SnowFlake雪花算法

雪花ID⽣成的是⼀个64位的⼆进制正整数，然后转换成10进制的数。64位⼆进制数由如下部

分组成：

snowﬂake id⽣成规则





1位标识符：始终是0，由于long基本类型在Java中是带符号的，最⾼位是符号位，正数是0，

负数是1，所以id⼀般是正数，最⾼位是0。

41位时间戳：41位时间截不是存储当前时间的时间截，⽽是存储时间截的差值（当前时间

截 - 开始时间截 )得到的值，这⾥的的开始时间截，⼀般是我们的id⽣成器开始使⽤的时间，

由我们程序来指定的。

10位机器标识码：可以部署在1024个节点，如果机器分机房（IDC）部署，这10位可以由 5

位机房ID + 5位机器ID 组成。

12位序列：毫秒内的计数，12位的计数顺序号⽀持每个节点每毫秒(同⼀机器，同⼀时间截)产

⽣4096个ID序号

优点

简单⾼效，⽣成速度快。

时间戳在⾼位，⾃增序列在低位，整个ID是趋势递增的，按照时间有序递增。

灵活度⾼，可以根据业务需求，调整bit位的划分，满⾜不同的需求。

 最后⼀个单词的⻓度

给你⼀个字符串 s，由若⼲单词组成，单词之间⽤空格隔开。返回字符串中最后⼀个单词

的⻓度。如果不存在最后⼀个单词，请返回 0 。

单词 是指仅由字⺟组成、不包含任何空格字符的最⼤⼦字符串。

示例 1：

输⼊：s = "Hello World"

输出：5

示例 2：

输⼊：s = " "

输出：0

提示：

1 <= s.lengt h <= 104

s 仅有英⽂字⺟和空格 ' ' 组成

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/length-of-last-word

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：





思路

标签：字符串遍历

从字符串末尾开始向前遍历，其中主要有两种情况

第⼀种情况，以字符串"Hello World"为例，从后向前遍历直到遍历到头或者遇到空格为⽌，

即为最后⼀个单词"World"的⻓度5

第⼆种情况，以字符串"Hello World "为例，需要先将末尾的空格过滤掉，再进⾏第⼀种情况

的操作，即认为最后⼀个单词为"World"，⻓度为5

所以完整过程为先从后过滤掉空格找到单词尾部，再从尾部向前遍历，找到单词头部，最后两

者相减，即为单词的⻓度

时间复杂度：O(n)，n为结尾空格和结尾单词总体⻓度

代码

1 class Solution {

2

public int lengthOfLastWord(String s) {

int end = s.length() - 1;

while(end >= 0 && s.charAt(end) == ' ') end--;

if(end < 0) return 0;

3

4

5

6

int start = end;

7

while(start >= 0 && s.charAt(start) != ' ') start--;

return end - start;

8

9

}

10 }

画解









作者：guanpengchn

链接：https://leetcode-cn.com/problems/length-of-last-word/solution/hua-jie-suan-

fa-58-zui-hou-yi-ge-dan-ci-de-chang-d/

来源：⼒扣（LeetCode）

著作权归作者所有。商业转载请联系作者获得授权，⾮商业转载请注明出处。

1.8 | 动态规划

 斐波那契数

斐波那契数，通常⽤ F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，

后⾯的每⼀项数字都是前⾯两项数字的和。也就是：

F(0) = 0，F(1) = 1

F(n) = F(n - 1) + F(n - 2)，其中 n > 1

给你 n ，请计算 F(n) 。

示例 1：





输⼊：2

输出：1

解释：F(2) = F(1) + F(0) = 1 + 0 = 1

示例 2：

输⼊：3

输出：2

解释：F(3) = F(2) + F(1) = 1 + 1 = 2

示例 3：

输⼊：4

输出：3

解释：F(4) = F(3) + F(2) = 2 + 1 = 3

提示：

0 <= n <= 30

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/ﬁbonacci-number

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

1 public int fib(int n) {

2

if(n<2) return n;

3

int[] f= new int[n+1];

4

f[0] = 0;

5

f[1]= 1;

6

for(int i = 2;i<=n;i++) f[i] =f[i-1]+f[i-2];

return f[n];

7

8 }

190

a-fei-8

作者：

11

链接：https://leetcode-cn.com/problems/fibonacci-number/solution/chang-you-

mian-shi-zhong-de-dong-tai-gui-e1ph/

12

13

来源：力扣（LeetCode）

著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

 不同路径

⼀个机器⼈位于⼀个 m x n ⽹格的左上⻆ （起始点在下图中标记为 “St art ” ）。

机器⼈每次只能向下或者向右移动⼀步。机器⼈试图达到⽹格的右下⻆（在下图中标记为

“Finish” ）。

问总共有多少条不同的路径？





示例 1：

输⼊：m = 3, n = 7

输出：28

示例 2：

输⼊：m = 3, n = 2

输出：3

解释：

从左上⻆开始，总共有 3 条路径可以到达右下⻆。

\1. 向右 -> 向下 -> 向下

\2. 向下 -> 向下 -> 向右

\3. 向下 -> 向右 -> 向下

示例 3：

输⼊：m = 7, n = 3

输出：28

示例 4：

输⼊：m = 3, n = 3

输出：6

提示：

1 <= m, n <= 100

题⽬数据保证答案⼩于等于 2 \* 109

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/unique-paths

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/unique-paths

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

我们令 dp[i][j] 是到达 i, j 最多路径

动态⽅程：dp[i][j] = dp[i-1][j] + dp[i][j-1]

注意，对于第⼀⾏ dp[0][j]，或者第⼀列 dp[i][0]，由于都是在边界，所以只能为 1





时间复杂度：O(m\*n)O(m∗n)

空间复杂度：O(m \* n)O(m∗n)

优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1]

所以我们只要记录这两个数，直接看代码吧！

代码

思路：

1 class Solution {

2

public int uniquePaths(int m, int n) {

int[][] dp = new int[m][n];

for (int i = 0; i < n; i++) dp[0][i] = 1;

for (int i = 0; i < m; i++) dp[i][0] = 1;

for (int i = 1; i < m; i++) {

for (int j = 1; j < n; j++) {

dp[i][j] = dp[i - 1][j] + dp[i][j - 1];

}

3

4

5

6

7

8

9

10

11

12

13 }

}

return dp[m - 1][n - 1];

}

优化1：空间复杂度 O(2n)

1 class Solution {

2

3

public int uniquePaths(int m, int n) {

int[] pre = new int[n];

int[] cur = new int[n];

Arrays.fill(pre, 1);

Arrays.fill(cur,1);

for (int i = 1; i < m;i++){

for (int j = 1; j < n; j++){

cur[j] = cur[j-1] + pre[j];

}

4

5

6

7

8

9

10

11

12

13

14

15 }

pre = cur.clone();

}

return pre[n-1];

}

优化2：空间复杂度 O(n)





1 class Solution {

2

public int uniquePaths(int m, int n) {

3

int[] cur = new int[n];

Arrays.fill(cur,1);

for (int i = 1; i < m;i++){

for (int j = 1; j < n; j++){

cur[j] += cur[j-1] ;

}

4

5

6

7

8

9

}

10

return cur[n-1];

11

}

12 }

134

15

powcai

作者：

链接：https://leetcode-cn.com/problems/unique-paths/solution/dong-tai-gui-

hua-by-powcai-2/

16

17

来源：力扣（LeetCode）

著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

 爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的⽅法可以爬到楼顶呢？

注意：给定 n 是⼀个正整数。

示例 1：

输⼊： 2

输出： 2

解释： 有两种⽅法可以爬到楼顶。

\1. 1 阶 + 1 阶

\2. 2 阶

示例 2：

输⼊： 3

输出： 3

解释： 有三种⽅法可以爬到楼顶。

\1. 1 阶 + 1 阶 + 1 阶

\2. 1 阶 + 2 阶

\3. 2 阶 + 1 阶

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/climbing-stairs

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。





参考回答：

本问题其实常规解法可以分成多个⼦问题，爬第n阶楼梯的⽅法数量，等于 2 部分之和

爬上 n-1n−1 阶楼梯的⽅法数量。因为再爬1阶就能到第n阶

爬上 n-2n−2 阶楼梯的⽅法数量，因为再爬2阶就能到第n阶

所以我们得到公式 dp[n] = dp[n-1] + dp[n-2]dp[n]=dp[n−1]+dp[n−2]

同时需要初始化 dp[0]=1dp[0]=1 和 dp[1]=1dp[1]=1

时间复杂度：O(n)O(n)

画解





代码

1 class Solution {

2

public int climbStairs(int n) {

3

int[] dp = new int[n + 1];

dp[0] = 1;

4

5

dp[1] = 1;

6

for(int i = 2; i <= n; i++) {

dp[i] = dp[i - 1] + dp[i - 2];

}

7

8

9

return dp[n];

10

}

11 }

123 作者：guanpengchn

14 链接：https://leetcode-cn.com/problems/climbing-stairs/solution/hua-jie-

suan-fa-70-pa-lou-ti-by-guanpengchn/

15 来源：力扣（LeetCode）

16 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。





 零钱兑换

给定不同⾯额的硬币 coins 和⼀个总⾦额 amount。编写⼀个函数来计算可以凑成总⾦额

所需的最少的硬币个数。如果没有任何⼀种硬币组合能组成总⾦额，返回 -1。

你可以认为每种硬币的数量是⽆限的。

示例 1：

输⼊：coins = [1, 2, 5], amount = 11

输出：3

解释：11 = 5 + 5 + 1

示例 2：

输⼊：coins = [2], amount = 3

输出：-1

示例 3：

输⼊：coins = [1], amount = 0

输出：0

示例 4：

输⼊：coins = [1], amount = 1

输出：1

示例 5：

输⼊：coins = [1], amount = 2

输出：2

提示：

1 <= coins.length <= 12

1 <= coins[i] <= 231 - 1

0 <= amount <= 104

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/coin-change

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

看题⽬的问法，只问最优值是多少，没有要我们求最优解，⼀般情况下可以⽤「动态规

划」解决。





动态规划与记忆化递归

思路：分析最优⼦结构。根据示例 1：

输⼊: coins = [1, 2, 5], amount = 11

凑成⾯值为 1111 的最少硬币个数可以由以下三者的最⼩值得到：

凑成⾯值为 1010 的最少硬币个数 + ⾯值为 1 的这⼀枚硬币；

凑成⾯值为 99 的最少硬币个数 + ⾯值为 2 的这⼀枚硬币；

凑成⾯值为 66 的最少硬币个数 + ⾯值为 5 的这⼀枚硬币。

即 dp[11] = min (dp[10] + 1, dp[9] + 1, dp[6] + 1)。

可以直接把问题的问法设计成状态。

第 1 步：定义「状态」。dp[i] ：凑⻬总价值 i 需要的最少硬币个数；

第 2 步：写出「状态转移⽅程」。根据对示例 1 的分析：

dp[amount] = min(dp[amount], 1 + dp[amount - coins[i]]) for i in [0, len - 1] if coins[i]

<= amount

说明：感谢 @paau 朋友纠正状态转移⽅程。

注意：

单枚硬币的⾯值⾸先要⼩于等于 当前要凑出来的⾯值；

剩余的那个⾯值也要能够凑出来，例如：求 dp[11] 需要参考 dp[10]。如果不能凑出

dp[10]，则 dp[10] 应该等于⼀个不可能的值，可以设计为 11 + 1，也可以设计为 -1 ，它们

的区别只是在编码的细节上不⼀样。

再次强调：新状态的值要参考的值以前计算出来的「有效」状态值。因此，不妨先假设凑不出

来，因为求的是⼩，所以设置⼀个不可能的数。

参考代码 ：

注意：要求的是「恰好凑出⾯值」，所以初始化的时候需要赋值为⼀个不可能的值：amount

\+ 1。只有在有「正常值」的时候，「状态转移」才可以正常发⽣。

1 import java.util.Arrays;

23 public class Solution {

45

6

7

public int coinChange(int[] coins, int amount) {

// 给 0 占位

int[] dp = new int[amount + 1];





89

10

112

13

14

15

16

17

18

19

20

212

23

24

25

26

27 }

// 注意：因为要比较的是最小值，这个不可能的值就得赋值成为一个最大值

Arrays.fill(dp, amount + 1);

// 理解 dp[0] = 0 的合理性，单独一枚硬币如果能够凑出面值，符合最优子结构

dp[0] = 0;

for (int i = 1; i <= amount; i++) {

for (int coin : coins) {

if (i - coin >= 0 && dp[i - coin] != amount + 1) {

dp[i] = Math.min(dp[i], 1 + dp[i - coin]);

}

}

}

if (dp[amount] == amount + 1) {

dp[amount] = -1;

}

return dp[amount];

}

复杂度分析：

时间复杂度：O(N \t imes amount)O(N×amount)，这⾥ NN 是可选硬币的种类数，

amountamount 是题⽬输⼊的⾯值；

空间复杂度：O(amount)O(amount)，状态数组的⼤⼩为 amountamount。

「动态规划」是「⾃底向上」求解。事实上，可以 直接⾯对问题求解 ，即「⾃顶向下」，但

是这样的问题有 重复⼦问题，需要缓存已经求解过的答案，这叫 记忆化递归。

作者：liweiwei1419

[链接：](https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-shi-yong-wan-quan-bei-bao-wen-ti-/)[https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-shi-](https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-shi-yong-wan-quan-bei-bao-wen-ti-/)

[yong-wan-quan-bei-bao-wen-ti-/](https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-shi-yong-wan-quan-bei-bao-wen-ti-/)

来源：⼒扣（LeetCode）

著作权归作者所有。商业转载请联系作者获得授权，⾮商业转载请注明出处。

 打家劫舍

你是⼀个专业的⼩偷，计划偷窃沿街的房屋。每间房内都藏有⼀定的现⾦，影响你偷窃的

唯⼀制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同⼀晚上

被⼩偷闯⼊，系统会⾃动报警。

给定⼀个代表每个房屋存放⾦额的⾮负整数数组，计算你 不触动警报装置的情况下 ，⼀夜

之内能够偷窃到的最⾼⾦额。

示例 1：

输⼊：[1,2,3,1]

输出：4

解释：偷窃 1 号房屋 (⾦额 = 1) ，然后偷窃 3 号房屋 (⾦额 = 3)。

偷窃到的最⾼⾦额 = 1 + 3 = 4 。

示例 2：





输⼊：[2,7,9,3,1]

输出：12

解释：偷窃 1 号房屋 (⾦额 = 2), 偷窃 3 号房屋 (⾦额 = 9)，接着偷窃 5 号房屋 (⾦额 =

1)。

偷窃到的最⾼⾦额 = 2 + 9 + 1 = 12 。

提示：

0 <= nums.length <= 100

0 <= nums[i] <= 400

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/house-robber

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

思路

标签：动态规划

动态规划⽅程：dp[n] = MAX( dp[n-1], dp[n-2] + num )

由于不可以在相邻的房屋闯⼊，所以在当前位置 n 房屋可盗窃的最⼤值，要么就是 n-1 房屋

可盗窃的最⼤值，要么就是 n-2 房屋可盗窃的最⼤值加上当前房屋的值，⼆者之间取最⼤值

举例来说：1 号房间可盗窃最⼤值为 33 即为 dp[1]=3，2 号房间可盗窃最⼤值为 44 即为

dp[2]=4，3 号房间⾃身的值为 22 即为 num=2，那么 dp[3] = MAX( dp[2], dp[1] + num )

= MAX(4, 3+2) = 5，3 号房间可盗窃最⼤值为 55

时间复杂度：O(n)O(n)，nn 为数组⻓度

代码

1 class Solution {

2

public int rob(int[] nums) {

3

4

int len = nums.length;

if(len == 0)

5

return 0;

6

int[] dp = new int[len + 1];

7

dp[0] = 0;

8

dp[1] = nums[0];

9

for(int i = 2; i <= len; i++) {

10

11

12

13

14 }

dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]);

}

return dp[len];

}

画解









作者：guanpengchn

链接：https://leetcode-cn.com/problems/house-robber/solution/hua-jie-suan-fa-

198-da-jia-jie-she-by-guanpengchn/

来源：⼒扣（LeetCode）

著作权归作者所有。商业转载请联系作者获得授权，⾮商业转载请注明出处。

 编辑距离

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使⽤的最少操作

数。

你可以对⼀个单词进⾏如下三种操作：

插⼊⼀个字符

删除⼀个字符

替换⼀个字符

示例 1：

输⼊：word1 = "horse", word2 = "ros"

输出：3

解释：

horse -> rorse (将 'h' 替换为 'r')

rorse -> rose (删除 'r')

rose -> ros (删除 'e')

示例 2：

输⼊：word1 = "int ent ion", word2 = "execution"

输出：5

解释：

int ent ion -> inent ion (删除 't ')

inent ion -> enention (将 'i' 替换为 'e')





enention -> exent ion (将 'n' 替换为 'x')

exent ion -> exect ion (将 'n' 替换为 'c')

exect ion -> execution (插⼊ 'u')

提示：

0 <= word1.length, word2.length <= 500

word1 和 word2 由⼩写英⽂字⺟组成

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/edit-distance

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

动态规划：

dp[i][j] 代表 word1 到 i 位置转换成 word2 到 j 位置需要最少步数

所以，

当 word1[i] == word2[j]，dp[i][j] = dp[i-1][j-1]；

当 word1[i] != word2[j]，dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1

其中，dp[i-1][j-1] 表示替换操作，dp[i-1][j] 表示删除操作，dp[i][j-1] 表示插⼊操作。

注意，针对第⼀⾏，第⼀列要单独考虑，我们引⼊ '' 下图所示：

第⼀⾏，是 word1 为空变成 word2 最少步数，就是插⼊操作

第⼀列，是 word2 为空，需要的最少步数，就是删除操作

再附上⾃顶向下的⽅法，⼤家可以提供 Java 版吗？





代码：

⾃底向上

1 class Solution {

2

3

public int minDistance(String word1, String word2) {

int n1 = word1.length();

4

int n2 = word2.length();

5

int[][] dp = new int[n1 + 1][n2 + 1];

// 第一行

6

7

for (int j = 1; j <= n2; j++) dp[0][j] = dp[0][j - 1] + 1;

// 第一列

8

9

for (int i = 1; i <= n1; i++) dp[i][0] = dp[i - 1][0] + 1;

for (int i = 1; i <= n1; i++) {

for (int j = 1; j <= n2; j++) {

if (word1.charAt(i - 1) == word2.charAt(j - 1)) dp[i][j] =

101

12

13

dp[i - 1][j - 1];

else dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i]

[j - 1]), dp[i - 1][j]) + 1;

14

15

}

16

}

17

return dp[n1][n2];

18

}

19 }

201

22

powcai

作者：

链接：https://leetcode-cn.com/problems/edit-distance/solution/zi-di-xiang-

shang-he-zi-ding-xiang-xia-by-powcai-3/

23

24

来源：力扣（LeetCode）

著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

2 | C++ ⼯程师

2.1 | 数组

 请你回答⼀下Array&List， 数组和链表的区别

参考回答：

数组的特点：

数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中

任何元素。数组的插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都

要向后移。删除数据时，这个数据后面的数据都要往前移动。但数组的随机读取效率很高。因

为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。如果应用需要快

速访问数据，很少或不插入和删除元素，就应该用数组。数组需要预留空间，在使用前要先申





请占内存的大小，可能会浪费内存空间。并且数组不利于扩展，数组定义的空间不够时要重新

定义数组。

链表的特点：

链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。比如：上一

个元素有个指针指到下一个元素，以此类推，直到最后一个元素。如果要访问链表中一个元

素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数

据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你

就需要用链表数据结构了。不指定大小，扩展方便。链表大小不用定义，数据随意增删。

各自的优缺点

数组的优点：

\1. 随机访问性强

\2. 查找速度快

数组的缺点:

\1. 插入和删除效率低

\2. 可能浪费内存

\3. 内存空间要求高，必须有足够的连续内存空间。

\4. 数组大小固定，不能动态拓展

链表的优点:

\1. 插入删除速度快

\2. 内存利用率高，不会浪费内存

\3. 大小没有固定，拓展很灵活。

链表的缺点:

不能随机查找，必须从第一个开始遍历，查找效率低

 ⼀组有序数（从⼩到⼤排列），有负有正，找出绝对值最⼩值

参考回答：

1 int i = 0;

2 while( a[i] < 0){

3

i++;

4 }

5 if(a[i] + a[i-1] <= 0)





6

return a[i];

7 else

8

return a[i-1];

190 链接：

https://www.nowcoder.com/questionTerminal/bde7945561b546baa3b79b8d5850422b

11 来源：牛客

 数组中重复的数字

在⼀个⻓度为n的数组⾥的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不

知道有⼏个数字是重复的。也不知道每个数字重复⼏次。请找出数组中第⼀个重复的数字。

例如，如果输⼊⻓度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是第⼀个重复的数字2。没有

重复的数字返回-1。

示例1

输⼊

1 [2,3,1,0,2,5,3]

输出

1 2

参考回答：

直接使用map，遍历一遍数组，当第一次出现重复的值时，此时map值大于1，直接返回得到

答案

1 class Solution {

2 public:

3

4

/\*\*

\* 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可

5

\*

6

\*

7

\* @param numbers int整型vector

\* @return int整型

8

9

\*/

10

11

12

13

14

15

16

17

18

19

20

21 };

int duplicate(vector<int>& numbers) {

if(numbers.size()<=1) return -1;

// write code here

unordered\_map<int,int> map;

for(int i = 0;i<numbers.size();i++){

map[numbers[i]]++;

if(map[numbers[i]]>1) return numbers[i];

}

return -1;

}

[链接：](https://www.nowcoder.com/questionTerminal/6fe361ede7e54db1b84adc81d09d8524)[https://www.nowcoder.com/questionTerminal/6fe361ede7e54db1b84adc81d09d](https://www.nowcoder.com/questionTerminal/6fe361ede7e54db1b84adc81d09d8524)

[8524](https://www.nowcoder.com/questionTerminal/6fe361ede7e54db1b84adc81d09d8524)

来源：⽜客⽹





 一个长度为N的整形数组，数组中每个元素的取值范围是[0,n-1],判断该数组否有重

复的数，请说一下你的思路并手写代码

参考回答：

把每个数放到自己对应序号的位置上，如果其他位置上有和自己对应序号相同的数，那么即为

有重复的数值。时间复杂度为O(N),同时为了节省空间复杂度，可以在原数组上进行操作，空

间复杂度为O(1)

1 bool IsDuplicateNumber(int \*array, int n)

2 {

3 if(array==NULL) return false;

4 int i,temp;

5 for(i=0;i<n;i++)

6 {

7 while(array[i]!=i)

8 {

9 if(array[array[i]]==array[i])

10 return true;

11 temp=array[array[i]];

12 array[array[i]]=array[i];

13 array[i]=temp;

14 }

15 }

16 return false;

17 }

2.2 | 排序

 ⼿写⼀下快排的代码

参考回答：

1 int once\_quick\_sort(vector<int> &data, int left, int right)

2 {

3 int key = data[left];

4 while (left < right)

5 {

6 while (left < right && key <= data[right])

7 {

8 right--;

9 }

10 if (left < right)

11 {

12 data[left++] = data[right];

13 }

14 while (left < right && key > data[left])

15 {

16 left++;





17 }

18 if (left < right)

19 {

20 data[right--] = data[left];

21 }

22 }

23 data[left] = key;

24 return left;

25 }

26 int quick\_sort(vector<int> & data, int left, int right)

27 {

28 if (left >= right )

29 {

30 return 1;

31 }

32 int middle = 0;

33 middle = once\_quick\_sort(data, left, right);

34 quick\_sort(data, left, middle-1);

35 quick\_sort(data, middle + 1, right);

36 }；

 介绍⼀下各种排序算法及其复杂度

参考回答：

插入排序：对于一个带排序数组来说，其初始有序数组元素个数为1，然后从第二个元素，插

入到有序数组中。对于每一次插入操作，从后往前遍历当前有序数组，如果当前元素大于要插

入的元素，则后移一位；如果当前元素小于或等于要插入的元素，则将要插入的元素插入到当

前元素的下一位中。

希尔排序：先将整个待排序记录分割成若干子序列，然后分别进行直接插入排序，待整个序列

中的记录基本有序时，在对全体记录进行一次直接插入排序。其子序列的构成不是简单的逐段

分割，而是将每隔某个增量的记录组成一个子序列。希尔排序时间复杂度与增量序列的选取有

关，其最后一个值必须为1.

归并排序：该算法采用分治法；对于包含m个元素的待排序序列，将其看成m个长度为1的子

序列。然后两两合归并，得到n/2个长度为2或者1的有序子序列；然后再两两归并，直到得到

1个长度为m的有序序列。

冒泡排序：对于包含n个元素的带排序数组，重复遍历数组，首先比较第一个和第二个元素，

若为逆序，则交换元素位置；然后比较第二个和第三个元素，重复上述过程。每次遍历会把当

前前n-i个元素中的最大的元素移到n-i位置。遍历n次，完成排序。





快速排序：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另

外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过

程可以递归进行，以此达到整个数据变成有序序列。

选择排序：每次循环，选择当前无序数组中最小的那个元素，然后将其与无序数组的第一个元

素交换位置，从而使有序数组元素加1，无序数组元素减1.初始时无序数组为空。

堆排序：堆排序是一种选择排序，利用堆这种数据结构来完成选择。其算法思想是将带排序数

据构造一个最大堆（升序）/最小堆（降序），然后将堆顶元素与待排序数组的最后一个元素

交换位置，此时末尾元素就是最大/最小的值。然后将剩余n-1个元素重新构造成最大堆/最小

堆。

各个排序的时间复杂度、空间复杂度及稳定性如下：

 稳定排序有哪⼏种？

参考回答：

基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序

 请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素

时，还可以使用什么不同的方法求第k大的元素

参考回答：

首先使用快速排序算法将数组按照从大到小排序，然后取第k个，其时间复杂度最快为

O(nlogn)

使用堆排序，建立最大堆，然后调整堆，知道获得第k个元素，其时间复杂度为O(n+klogn)

首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描

过程中，前面有k-1个数则为第k大的数

利用快排思想，从数组中随机选择一个数i，然后将数组分成两部分Dl,Dr，Dl的元素都小于

i,Dr的元素都大于i。然后统计Dr元素个数，如果Dr元素个数等于k-1,那么第k大的数即为k，如

果Dr元素个数小于k,那么继续求Dl中第k-Dr大的元素；如果Dr元素个数大于k,那么继续求Dr中

第k大的元素。

当有相同元素的时候，





首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描

过程中，前面有k-1个数则为第k大的数，平均情况下时间复杂度为O(n)

 请问海量数据如何去取最大的k个

参考回答：

1.直接全部排序（只适用于内存够的情况）

当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数据

全部排序，然后取排序后的数据中的前K个。

这种方法对数据量比较敏感，当数据量较大的情况下，内存不能完全容纳全部数据，这种方法

便不适应了。即使内存能够满足要求，该方法将全部数据都排序了，而题目只要求找出top K

个数据，所以该方法并不十分高效，不建议使用。

2.快速排序的变形 （只使用于内存够的情况）

这是一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只需

要找出前K个最大的就行。

这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放到它的前面，比

划分元小的元素放到它的后面，此时完成了一趟排序。如果此时这个划分元的序号index刚好

等于K，那么这个划分元以及它左边的数，刚好就是前K个最大的元素；如果index > K，那

么前K大的数据在index的左边，那么就继续递归的从index-1个数中进行一趟排序；如果

index < K，那么再从划分元的右边继续进行排序，直到找到序号index刚好等于K为止。再将

前K个数进行排序后，返回Top K个元素。这种方法就避免了对除了Top K个元素以外的数据

进行排序所带来的不必要的开销。

3.最小堆法

这是一种局部淘汰法。先读取前K个数，建立一个最小堆。然后将剩余的所有数字依次与最小

堆的堆顶进行比较，如果小于或等于堆顶数据，则继续比较下一个；否则，删除堆顶元素，并

将新数据插入堆中，重新调整最小堆。当遍历完全部数据后，最小堆中的数据即为最大的K个

数。

4.分治法

将全部数据分成N份，前提是每份的数据都可以读到内存中进行处理，找到每份数据中最大的

K个数。此时剩下N\*K个数据，如果内存不能容纳N\*K个数据，则再继续分治处理，分成M





份，找出每份数据中最大的K个数，如果M\*K个数仍然不能读到内存中，则继续分治处理。直

到剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理。

5.Hash法

如果这些数据中有很多重复的数据，可以先通过hash法，把重复的数去掉。这样如果重复率

很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则

可以直接排序；否则可以使用分治法或者最小堆法来处理数据。

 请问快排的时间复杂度最差是多少？什么时候时间最差

参考回答：

O（N2),元素本来倒序排列用时最多

 请你介绍一下快排算法；以及什么是稳定性排序，快排是稳定性的吗；快排算法最

差情况推导公式

参考回答：

1、快排算法

根据哨兵元素，用两个指针指向待排序数组的首尾，首指针从前往后移动找到比哨兵元素大

的，尾指针从后往前移动找到比哨兵元素小的，交换两个元素，直到两个指针相遇，这是一趟

排序，经常这趟排序后，比哨兵元素大的在右边，小的在左边。经过多趟排序后，整个数组有

序。

稳定性：不稳定

平均时间复杂度：O(nlogn)

2、稳定排序

假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相

对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在

r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。

快排算法是不稳定的排序算法。例如：

待排序数组:int a[] ={1, 2, 2, 3, 4, 5, 6};

若选择a[2]（即数组中的第二个2）为枢轴，而把大于等于比较子的数均放置在大数数组中，

则a[1]（即数组中的第一个2）会到pivot的右边， 那么数组中的两个2非原序。

若选择a[1]为比较子，而把小于等于比较子的数均放置在小数数组中，则数组中的两个2顺序

也非原序。

3、快排最差情况推倒





在快速排序的早期版本中呢，最左面或者是最右面的那个元素被选为枢轴，那最坏的情况就会

在下面的情况下发生啦：

1）数组已经是正序排过序的。 （每次最右边的那个元素被选为枢轴）

2）数组已经是倒序排过序的。 （每次最左边的那个元素被选为枢轴）

3）所有的元素都相同（1、2的特殊情况）

因为这些案例在用例中十分常见，所以这个问题可以通过要么选择一个随机的枢轴，或者选择

一个分区中间的下标作为枢轴，或者（特别是对于相比更长的分区）选择分区的第一个、中

间、最后一个元素的中值作为枢轴。有了这些修改，那快排的最差的情况就不那么容易出现

了，但是如果输入的数组最大（或者最小元素）被选为枢轴，那最坏的情况就又来了。

快速排序，在最坏情况退化为冒泡排序，需要比较O(n2)次（n(n - 1)/2次）。

2.3 | 动态规划

 ⼿写代码：最⻓公共连续⼦序列

参考回答：

1 int substr(string & str1, string &str2)

2 {

3 int len1 = str1.length();

4 int len2 = str2.length();

5 vector<vector<int>>dp(len1,vector<int>(len2,0));

6 for (int i = 0; i < len1; i++)

7 {

8 dp[i][0] = str1[i]==str1[0]?1:0;

9 }

10 for (int j = 0; j <= len2; j++)

11 {

12 dp[0][j] = str1[0]==str2[j]?1:0;

13 }

14 for (int i = 1; i < len1; i++)

15 {

16 for (int j = 1; j < len2; j++)

17 {

18 if (str1[i] == str2[j])

19 {

20 dp[i][j] = dp[i - 1][j - 1]+1;

21 }

22 }





23 }

24 int longest = 0;

25 int longest\_index = 0;

26 for (int i = 0; i < len1; i++)

27 {

28 for (int j = 0; j < len2; j++)

29 {

30 if (longest < dp[i][j])

31 {

32 longest = dp[i][j];

33 longest\_index = i;

34 }

35 }

36 }

378 // longest

i

字符串为从第 个开始往前数 个

39 for (int i = longest\_index-longest+1; i <=longest\_index; i++)

40 {

41 cout << str1[i] << endl;

42 }

43 return longest;

44 }

 ⼿写代码：求⼀个字符串最⻓回⽂⼦串

参考回答：

1 int LongestPalindromicSubstring(string & a)

2 {

3 int len = a.length();

4 vector<vector<int>>dp(len, vector<int>(len, 0));

5 for (int i = 0; i < len; i++)

6 {

7 dp[i][i] = 1;

8 }

9 int max\_len = 1;

10 int start\_index = 0;

11 for (int i= len - 2; i >= 0; i--)

12 {

13 for (int j = i + 1; j < len; j++)

14 {

15 if (a[i] == a[j])

16 {

17 if (j - i == 1)





18 {

19 dp[i][j] = 2;

20 }

21 else

22 {

23 if (j - i > 1)

24 {

25 dp[i][j] = dp[i + 1][j - 1] + 2;

26 }

27 }

28 if (max\_len < dp[i][j])

29 {

30 max\_len = dp[i][j];

31 start\_index = i;

32 }

33 }

34 else

35 {

36 dp[i][j] = 0;

37 }

38 }

39 }

40 cout << "max len is " << max\_len << endl;

41 cout << "star index is" << start\_index << endl;

42 return max\_len;

43 }

44

 ⼿写代码：求最⼤⼦序和

给定⼀个整数数组 nums ，找到⼀个具有最⼤和的连续⼦数组（⼦数组最少包含⼀个元

素），返回其最⼤和。

示例 1：

输⼊：nums = [-2,1,-3,4,-1,2,1,-5,4]

输出：6

解释：连续⼦数组 [4,-1,2,1] 的和最⼤，为 6 。

示例 2：

输⼊：nums = [1]

输出：1

示例 3：

输⼊：nums = [0]

输出：0





示例 4：

输⼊：nums = [-1]

输出：-1

示例 5：

输⼊：nums = [-100000]

输出：-100000

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/maximum-subarray

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：













1 class Solution

2 {

3 public:

4

5

int maxSubArray(vector<int> &nums)

{

6

//类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值

int result = INT\_MIN;

7

8

int numsSize = int(nums.size());

//dp[i]表示nums中以nums[i]结尾的最大子序和

vector<int> dp(numsSize);

dp[0] = nums[0];

9

10

11

12

13

14

15

16

17

result = dp[0];

for (int i = 1; i < numsSize; i++)

{

dp[i] = max(dp[i - 1] + nums[i], nums[i]);

result = max(result, dp[i]);

}





189

return result;

20

}

21 };

1 class Solution

2 {

3 public:

4

5

int maxSubArray(vector<int> &nums)

{

6

//类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值

7

int result = INT\_MIN;

int numsSize = int(nums.size());

//因为只需要知道dp的前一项，我们用int代替一维数组

int dp(nums[0]);

8

9

10

11

12

13

14

15

16

178

19

20 };

result = dp;

for (int i = 1; i < numsSize; i++)

{

dp = max(dp + nums[i], nums[i]);

result = max(result, dp);

}

return result;

}

212

23

pinku-2

作者：

链接：https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-

xu-he-cshi-xian-si-chong-jie-fa-bao-li-f/

24

25

来源：力扣（LeetCode）

著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

2.4 | 链表

 请你手写代码，如何合并两个有序链表

参考回答：

1 class Solution {

2 public:

3 ListNode\* mergeTwoLists(ListNode\* l1, ListNode\* l2) {

4 if(l1 == NULL)

5 {

6 return l2;

7 }





8 if(l2 == NULL)

9 {

10 return l1;

11 }

12 if(l1->val < l2->val)

13 {

14 l1->next=mergeTwoLists(l1->next,l2);

15 return l1;

16 }

17 else

18 {

19 l2->next=mergeTwoLists(l1,l2->next);

20 return l2;

21 }

22 }

23 };

 手写代码：反转链表

参考回答：

1 Void reversal\_list(mylist \* a\_list)

2 {

3 mylist \* forward\_node = nullptr;

4 mylist \* cur\_node = a\_list->next;

5 mylist\* next\_node = cur\_node->next;

6 if(cur\_node == nullptr)

7 {

8 return ;

9 }

10 while(1)

11 {

12 cur\_node->next = forward\_node;

13 forward\_node = cur\_node;

14 cur\_node = next\_node;

15 if(cur\_node == nullptr)

16 {

17 break;

18 }

19 next\_node = cur\_node->next;

20 }

21 a\_list->next = forward\_node;

22 }





 判断一个链表是否为回文链表，说出你的思路并手写代码

参考回答：

思路：使用栈存储链表前半部分，然后一个个出栈，与后半部分元素比较，如果链表长度未

知，可以使用快慢指针的方法，将慢指针指向的元素入栈，然后如果快指针指向了链表尾部，

此时慢指针指向了链表中间

1 bool is\_palindromic\_list2(mylist \*a\_list)

2 {

3 if(a\_list == nullptr)

4 {

5 return false;

6 }

7 stack<int>list\_value;

8 mylist \* fast =a\_list;

9 mylist \*slow =a\_list;

10 while(fast->next!=nullptr && fast->next->next!=nullptr)

11 {

12 list\_value.push(slow->next->value);

13 slow = slow->next;

14 fast = fast->next->next;

15 }

16 cout<<"middle elem value is "<<slow->next->value<<endl;

17 if(fast->next != nullptr)

18 {

19 cout<<"the list has odd num of node"<<endl;

20 slow =slow->next;

21 }

22 int cur\_value;

23 while(!list\_value.empty())

24 {

25 cur\_value = list\_value.top();

26 cout<<"stack top value is"<<cur\_value<<endl;

27 cout<<"list value is "<<slow->next->value<<endl;

28 if(cur\_value != slow->next->value)

29 {

30 return false;

31 }

32 list\_value.pop();

33 slow = slow->next;

34 }

35 return true;





36 }

 请问什么是单向链表，如何判断两个单向链表是否相交

参考回答：

考察点：数据结构，算法

公司：百度

1、单向链表

单向链表（单链表）是链表的一种，其特点是链表的链接方向是单向的，对链表的访问要通过

顺序读取从头部开始；链表是使用指针进行构造的列表；又称为结点列表，因为链表是由一个

个结点组装起来的；其中每个结点都有指针成员变量指向列表中的下一个结点。

列表是由结点构成，head指针指向第一个成为表头结点，而终止于最后一个指向nuLL的指

针。

2、判断两个链表是否相交

1）方法1：

链表相交之后，后面的部分节点全部共用，可以用2个指针分别从这两个链表头部走到尾部，

最后判断尾部指针的地址信息是否一样，若一样则代表链表相交！

2）方法2：

可以把其中一个链表的所有节点地址信息存到数组中，然后把另一个链表的每一个节点地址信

息遍历数组，若相等，则跳出循环，说明链表相交。进一步优化则是进行hash排序，建立

hash表。

2.5 | 高级算法

 什么是LRU缓存

参考回答：

LRU(最近最少使用)算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据

最近被访问过，那么将来被访问的几率也更高

实现：使用一个链表保存缓存数据，将新数据插入到头部，每当缓存命中时，则将命中的数据

移动到链表头部，当链表满的时候，将链表尾部的数据丢弃。

 请你说一说洗牌算法

参考回答：

1、Fisher-Yates Shuffle算法

最早提出这个洗牌方法的是 Ronald A. Fisher 和 Frank Yates，即 Fisher–Yates Shuffle，其

基本思想就是从原始数组中随机取一个之前没取过的数字到新的数组中，具体如下：





1）初始化原始数组和新数组，原始数组长度为n(已知)。

2）从还没处理的数组（假如还剩k个）中，随机产生一个[0, k)之间的数字p（假设数组从0开

始）。

3）从剩下的k个数中把第p个数取出。

4）重复步骤2和3直到数字全部取完。

5）从步骤3取出的数字序列便是一个打乱了的数列。

时间复杂度为O(n\*n)，空间复杂度为O(n)。

2）Knuth-Durstenfeld Shuffle

Knuth 和 Durstenfeld 在Fisher 等人的基础上对算法进行了改进，在原始数组上对数字进行

交互，省去了额外O(n)的空间。该算法的基本思想和 Fisher 类似，每次从未处理的数据中随

机取出一个数字，然后把该数字放在数组的尾部，即数组尾部存放的是已经处理过的数字。

算法步骤为：

\1. 建立一个数组大小为 n 的数组 arr，分别存放 1 到 n 的数值；

\2. 生成一个从 0 到 n - 1 的随机数 x；

\3. 输出 arr 下标为 x 的数值，即为第一个随机数；

\4. 将 arr 的尾元素和下标为 x 的元素互换；

\5. 同2，生成一个从 0 到 n - 2 的随机数 x；

\6. 输出 arr 下标为 x 的数值，为第二个随机数；

\7. 将 arr 的倒数第二个元素和下标为 x 的元素互换；

……

如上，直到输出m 个数为止

时间复杂度为O(n)，空间复杂度为O(1)，缺点必须知道数组长度n。

2.6 | 字符串

 给你一个字符串，找出第一个不重复的字符，如“abbbabcd”，则第一个不重复就

是c

参考回答：

使用哈希的思想，建立256个bool数组array，初始都为false,从头开始扫描字符串，扫到一

个，将以其ascii码为下标的元素置true。例如扫描到A的时候，执行：array['A']=true。第二

边扫描，扫到一个字母就以其ascii码为下标，去array数组中看其值，如果是true,返回改字

母，如果是false，继续扫描下一个字母。

 最⻓公共前缀

编写⼀个函数来查找字符串数组中的最⻓公共前缀。





如果不存在公共前缀，返回空字符串 ""。

示例 1：

输⼊：strs = ["ﬂower","ﬂow","ﬂight"]

输出："ﬂ"

示例 2：

输⼊：strs = ["dog","racecar","car"]

输出：""

解释：输⼊不存在公共前缀。

提示：

0 <= st rs.lengt h <= 200

0 <= st rs[i].lengt h <= 200

st rs[i] 仅由⼩写英⽂字⺟组成

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/longest-common-preﬁx

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

解题思路

先找出数组中字典序最⼩和最⼤的字符串，最⻓公共前缀即为这两个字符串的公共前缀

下⾯是 C++17 的代码

1 class Solution {

2 public:

3

4

5

6

7

string longestCommonPrefix(vector<string>& strs) {

if(strs.empty()) return "";

// c++17 结构化绑定

// str0, str1 分别是一个 pair<string, string> 的 first 和 second

const auto [str0, str1] = minmax\_element(strs.begin(),

strs.end());

8

for(int i = 0; i < str0->size(); ++i)

if(str0->at(i) != str1->at(i)) return str0->substr(0, i);

return \*str0;

9

10

11

}

12 };

等同的 C++11 代码如下

1 class Solution {

2 public:





3

4

5

6

7

string longestCommonPrefix(vector<string>& strs) {

if(strs.empty()) return "";

const auto p = minmax\_element(strs.begin(), strs.end());

for(int i = 0; i < p.first->size(); ++i)

if(p.first->at(i) != p.second->at(i)) return p.first-

\>substr(0, i);

return \*p.first;

8

9

}

10 };

作者：you-yuan-de-cang-qiong

[链接：](https://leetcode-cn.com/problems/longest-common-prefix/solution/zi-dian-xu-zui-da-he-zui-xiao-zi-fu-chuan-de-gong-/)[https://leetcode-cn.com/problems/longest-common-preﬁx/solution/zi-dian-xu-](https://leetcode-cn.com/problems/longest-common-prefix/solution/zi-dian-xu-zui-da-he-zui-xiao-zi-fu-chuan-de-gong-/)

[zui-da-he-zui-xiao-zi-fu-chuan-de-gong-/](https://leetcode-cn.com/problems/longest-common-prefix/solution/zi-dian-xu-zui-da-he-zui-xiao-zi-fu-chuan-de-gong-/)

来源：⼒扣（LeetCode）

著作权归作者所有。商业转载请联系作者获得授权，⾮商业转载请注明出处。

 有效的字⺟异位词

给定两个字符串 s 和 t ，编写⼀个函数来判断 t 是否是 s 的字⺟异位词。

示例 1:

输⼊: s = "anagram", t = "nagaram"

输出: t rue

示例 2:

输⼊: s = "rat", t = "car"

输出: f alse

说明:

你可以假设字符串只包含⼩写字⺟。

进阶:

如果输⼊字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/valid-anagram

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

⽅法⼀：sort

1 class Solution {

2 public:

3

bool isAnagram(string s, string t) {

sort(s.begin(), s.end());

sort(t.begin(), t.end());

return s == t;

4

5

6

7

}

8 };





⽅法⼆：map1

1 class Solution {

2 public:

3

bool isAnagram(string s, string t) {

4

if(s.size() != t.size()) return false;

unordered\_map<char, int> map;

for(char c : s) map[c] ++;

for(char c : t)

5

6

7

8

if(-- map[c] == -1) return false;

return true;

9

10

}

11 };

⽅法三：map2

1 class Solution {

2 public:

3

bool isAnagram(string s, string t) {

4

unordered\_map<char, int> map;

for(int i = 0; i < max(s.size(), t.size()); i ++)

map[s[i]] ++, map[t[i]] --;

for(auto it : map)

5

6

7

8

if(it.second != 0) return false;

return true;

9

10

}

11 };

⽅法四：数组1(推荐)

1 class Solution {

2 public:

3

bool isAnagram(string s, string t) {

4

if(s.size() != t.size()) return false;

int hash[26] = {0};

5

6

for(char c : s) hash[c - 'a'] ++;

for(char c : t)

7

8

if(-- hash[c - 'a'] == -1) return false;

return true;

9

101

}

12 };

⽅法五：数组2

1 class Solution {

2 public:

3

bool isAnagram(string s, string t) {





4

if(s.size() != t.size()) return false;

int hash[26] = {0};

5

6

for(int i = 0; i < s.size(); i ++)

hash[s[i] - 'a'] ++, hash[t[i] - 'a'] --;

for(int i = 0; i < 26; i ++)

if(hash[i] != 0) return false;

return true;

7

8

9

10

112

}

13 };

145

16

OrangeMan

作者：

链接：https://leetcode-cn.com/problems/valid-anagram/solution/cjian-ji-dai-

ma-duo-chong-fang-fa-by-orangeman-10/

17

18

来源：力扣（LeetCode）

著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

3 | Golang ⼯程师

3.1 | 递归&回溯

 ⼿写代码：两数相加

给定⼀个整数数组 nums 和⼀个整数⽬标值 target，请你在该数组中找出 和为⽬标值 的

那 两个 整数，并返回它们的数组下标。

你可以假设每种输⼊只会对应⼀个答案。但是，数组中同⼀个元素不能使⽤两遍。

你可以按任意顺序返回答案。

示例 1：

输⼊：nums = [2,7,11,15], t arget = 9

输出：[0,1]

解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

示例 2：

输⼊：nums = [3,2,4], t arget = 6

输出：[1,2]

示例 3：

输⼊：nums = [3,3], t arget = 6

输出：[0,1]

提示：

2 <= nums.length <= 103

-109 <= nums[i] <= 109





-109 <= t arget <= 109

只会存在⼀个有效答案

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/two-sum

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

思路

定义辅助函数addTwoNumber(l1 \*List Node, l2 \*List Node, add int)，add指进位值，向右进

位。

l1、l2为空，进位值为0未递归边界条件。

计算add = l1.Val + l2.Val + add，add % 10为当前节点值，add / 10为下次递归进位值，相

邻递归次数之间节点连接起来即为所求。

复杂度

时间复杂度：O(Max(M,N))

代码实现

1 func addTwoNumbers(l1 \*ListNode, l2 \*ListNode) \*ListNode {

2

return addTwoNumber(l1, l2, 0)

3 }

45 func addTwoNumber(l1 \*ListNode, l2 \*ListNode, add int) \*ListNode{

6

7

if l1 == nil && l2 == nil && add == 0 {

return nil;

8

}

190

11

12

13

14

15

16

17

189

20

21

22

234

25 }

if l1 != nil {

add += l1.Val

l1 = l1.Next

}

if l2 != nil {

add += l2.Val

l2 = l2.Next

}

node := ListNode{

Val: add % 10,

Next: addTwoNumber(l1, l2, add / 10),

}

return &node

作者：somnus-23

[链接：](https://leetcode-cn.com/problems/add-two-numbers/solution/di-gui-shi-xian-by-somnus-23/)[https://leetcode-cn.com/problems/add-two-numbers/solution/di-gui-shi-xian-](https://leetcode-cn.com/problems/add-two-numbers/solution/di-gui-shi-xian-by-somnus-23/)

[by-somnus-23/](https://leetcode-cn.com/problems/add-two-numbers/solution/di-gui-shi-xian-by-somnus-23/)

来源：⼒扣（LeetCode）

著作权归作者所有。商业转载请联系作者获得授权，⾮商业转载请注明出处。

 ⼿写代码：括号⽣成

数字 n 代表⽣成括号的对数，请你设计⼀个函数，⽤于能够⽣成所有可能的并且 有效的

括号组合。





示例 1：

输⼊：n = 3

输出：["((()))","(()())","(())()","()(())","()()()"]

示例 2：

输⼊：n = 1

输出：["()"]

提示：

1 <= n <= 8

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/generate-parentheses

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

解题思路

使⽤递归解决问题

递归结束条件：当进⼊字符串的右括号多于已经进⼊的左括号就结束，当两个同时为零

时，存储下结果

代码

1 func generateParenthesis(n int) []string {

2

s := make([]string,0,0)

t := " "

3

4

brackets(n,n,&s,t[:0])

return s

5

6 }

78 func brackets(l int , r int ,s \*[]string ,t string){

9

if l ==0 && r==0{

10

\*s = append(\*s,t)

11

}

12

if l > r || l<0 || r<0{

return

13

14

}

15

brackets(l-1,r,s,t+"(")

brackets(l,r-1,s,t+")")

16

17 }

189 作者：xiao-xiao-xiao-niao-2

20 链接：https://leetcode-cn.com/problems/generate-parentheses/solution/di-

gui-de-jie-jue-fang-an-by-xiao-xiao-x-vkhi/

21 来源：力扣（LeetCode）

22 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。





 ⼿写代码：验证⼆叉搜索树

给定⼀个⼆叉树，判断其是否是⼀个有效的⼆叉搜索树。

假设⼀个⼆叉搜索树具有如下特征：

节点的左⼦树只包含⼩于当前节点的数。

节点的右⼦树只包含⼤于当前节点的数。

所有左⼦树和右⼦树⾃身必须也是⼆叉搜索树。

示例 1:

输⼊:

2

/ \

1 3

输出: t rue

示例 2:

输⼊:

5

/ \

1 4

/ \

3 6

输出: f alse

解释: 输⼊为: [5,1,4,null,null,3,6]。

根节点的值为 5 ，但是其右⼦节点值为 4 。

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/validate-binary-search-tree

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

思路

遇到树基本来说递归跑不掉了

简洁实现！！！

代码

1 /\*\*

2 \* Definition for a binary tree node.

3 \* type TreeNode struct {

4 \*

Val int

5 \*

Left \*TreeNode

Right \*TreeNode

6 \*

7 \* }

8 \*/

9 func isValidBST(root \*TreeNode) bool {

return validBST(root,math.MinInt64,math.MaxInt64)

10

11 }





123 func validBST(root \*TreeNode,min,max int) bool{

14

15

16

17

18

19

20

21

22

23

24

//递归结束条件

if root==nil{

return true

}

// 判断节点的值是不是在区间呢，不是的话就false结束

if root.Val<=min || root.Val>=max{

return false

}

//左递归 最大值改为当前节点值

//右递归 最小值改为当前节点值

return validBST(root.Left,min,root.Val) &&

validBST(root.Right,root.Val,max)

25 }

267 作者：feng-a

28 链接：https://leetcode-cn.com/problems/validate-binary-search-

tree/solution/98-yan-zheng-er-cha-sou-suo-shu-4ms-chao-ji-shao-d/

29 来源：力扣（LeetCode）

30 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

 ⼆叉树的最⼤深度

参考回答：

递归求解

我们知道，每个节点的深度与它左右⼦树的深度有关，且等于其左右⼦树最⼤深度值加上 1。

即：

maxDepth(root) = max(maxDept h(root .lef t ),

maxDept h(root .right )) + 1

以 [3,4,20,null,null,15,7] 为例：

<1>我们要对根节点的最⼤深度求解，就要对其左右⼦树的深度进⾏求解





<2>我们看出。以4为根节点的⼦树没有左右节点，其深度为 1 。⽽以 20 为根节点的

⼦树的深度，同样取决于它的左右⼦树深度。

<3>对于15和7的⼦树，我们可以⼀眼看出其深度为 1 。

<4>由此我们可以得到根节点的最⼤深度为:

1 maxDepth(root-3)





2 =max(\*\*maxDepth\*\*(sub-4),\*\*maxDepth\*\*(sub-20))+1

3 =max(1,max(\*\*maxDepth\*\*(sub-15),\*\*maxDepth\*\*(sub-7))+1)+1

4 =max(1,max(1,1)+1)+1

5 =max(1,2)+1

6 =3

根据分析，我们通过递归进⾏求解代码如下：

1 func maxDepth(root \*TreeNode) int {

2

if root == nil {

3

return 0

4

}

5

return max(maxDepth(root.Left), maxDepth(root.Right)) + 1

6 }

78 func max(a int, b int) int {

9

if a > b {

return a

}

10

11

12

return b

13 }

作者：ivan1

[链接：](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/duo-jie-fa-qiu-zui-da-shen-du-di-gui-di-gui-dfs-fe/)[https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/du](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/duo-jie-fa-qiu-zui-da-shen-du-di-gui-di-gui-dfs-fe/)

[o-jie-fa-qiu-zui-da-shen-du-di-gui-di-gui-dfs-fe/](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/duo-jie-fa-qiu-zui-da-shen-du-di-gui-di-gui-dfs-fe/)

来源：⼒扣（LeetCode）

著作权归作者所有。商业转载请联系作者获得授权，⾮商业转载请注明出处。

 ⼆叉树的最近公共祖先

给定⼀个⼆叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示

为⼀个节点 x，满⾜ x 是 p、q 的祖先且 x 的深度尽可能⼤（⼀个节点也可以是它⾃⼰的

祖先）。”

示例 1：

输⼊：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1

输出：3

解释：节点 5 和节点 1 的最近公共祖先是节点 3 。

示例 2：

输⼊：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4

输出：5

解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以

为节点本身。

示例 3：

输⼊：root = [1,2], p = 1, q = 2





输出：1

提示：

树中节点数⽬在范围 [2, 105] 内。

-109 <= Node.val <= 109

所有 Node.val 互不相同 。

p != q

p 和 q 均存在于给定的⼆叉树中。

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-

t ree

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

思路

我们想⼀下，对于根节点 root，p、q 的分布，有两种可能：

p、q 分居 root 的左右⼦树，则 LCA 为 root 。

p、q 在 root 的同⼀个⼦树中，问题转为规模⼩⼀点的相同问题。

定义递归函数

递归函数：返回当前⼦树中 p 和 q 的 LCA。如果没有 LCA，就返回 null。

从根root开始递归搜索，递归搜到各个⼦树……

如果遍历到 p 或 q，⽐⽅说 p，则 LCA 要么是当前的 p（q 在 p 的⼦树中），要么是 p 之

上的节点（q 不在 p 的⼦树中），不可能是 p 之下的节点。不⽤继续往下遍历，返回当前的

p。

当遍历到 null 节点，空树不存在 p 和 q，不存在 LCA，返回 null。

当遍历的节点 root 不是 p 或 q 或 null，则递归搜寻 root 的左右⼦树：

如果左右⼦树的递归都有结果，说明 p 和 q 分居 root 的左右⼦树，返回 root 。

如果只是⼀个⼦树递归调⽤有结果，说明 p 和 q 都在这个⼦树，返回该⼦树递归结果。

如果两个⼦树递归结果都为 null，说明 p 和 q 都不在这俩⼦树中，返回 null。

代码

1 func lowestCommonAncestor(root, p, q \*TreeNode) \*TreeNode {

2

3

if root == nil {

return nil

4

}

5

if root == q || root == p {

6

return root

7

}

8

left := lowestCommonAncestor(root.Left, p, q)

right := lowestCommonAncestor(root.Right, p, q)

if left != nil && right != nil {

return root

9

10

11





12

}

13

if left == nil {

return right

}

14

15

16

return left

17 }

作者：xiao\_ben\_zhu

[链接：](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/jsersi-lu-hao-li-jie-by-hyj8/)[https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tre](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/jsersi-lu-hao-li-jie-by-hyj8/)

[e/solution/jsersi-lu-hao-li-jie-by-hyj8/](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/jsersi-lu-hao-li-jie-by-hyj8/)

来源：⼒扣（LeetCode）

著作权归作者所有。商业转载请联系作者获得授权，⾮商业转载请注明出处。

 全排列

参考回答：

思路

每⼀位都有3种选择：1、2、3。

每⼀次都做选择，展开出⼀棵空间树，如下图。

利⽤约束条件「不能重复选」，做剪枝，剪去不会产⽣正确解的选项（分⽀）。

⽤⼀个 hashMap，记录选过的数，下次遇到相同的数，跳过。

这样就不会进⼊「不会得出解的分⽀」，做⽆效的搜索。

怎么写递归函数

我们要在这个包含解的空间树上，⽤ DFS（递归）的⽅式搜索出所有的解。

dfs 函数做的事：基于当前的 path，继续选数，直到构建出合法的path，加⼊解集。

递归的⼊⼝：dfs 执⾏传⼊空 path，什么都还没选。

函数体内，⽤ for 循环，枚举出当前所有的选项，并写 if 语句跳过剪枝项。





每⼀轮迭代，作出⼀个选择，基于它，继续选（递归调⽤）。

递归的出⼝：当构建的 pat h 数组⻓度等于 nums ⻓度，就选够了，加⼊解集。

为什么要回溯

我们不是找到⼀个排列就完事，要找出所有满⾜条件的排列。

递归结束时，结束的是当前的递归分⽀，还要去别的分⽀继续搜。

所以，要撤销当前的选择，回到选择前的状态，去选下⼀个选项，即切⼊下⼀个分⽀。

注意，往map添加的当前选择也要同时撤销。代表没有做这个选择。

退回来，把路⾛全，才能在⼀棵空间树中，回溯出所有的解。

代码

1 func permute(nums []int) [][]int {

2

3

res := [][]int{}

visited := map[int]bool{}

var dfs func(path []int)

dfs = func(path []int) {

if len(path) == len(nums) {

temp := make([]int, len(path))

copy(temp, path)

res = append(res, temp)

return

45

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

245

26

27 }

}

for \_, n := range nums {

if visited[n] {

continue

}

path = append(path, n)

visited[n] = true

dfs(path)

path = path[:len(path)-1]

visited[n] = false

}

}

dfs([]int{})

return res

作者：xiao\_ben\_zhu

[链接：](https://leetcode-cn.com/problems/permutations/solution/chou-xiang-cheng-jue-ce-shu-yi-ge-pai-lie-jiu-xian/)[https://leetcode-cn.com/problems/permutations/solution/chou-xiang-cheng-jue](https://leetcode-cn.com/problems/permutations/solution/chou-xiang-cheng-jue-ce-shu-yi-ge-pai-lie-jiu-xian/)

[-ce-shu-yi-ge-pai-lie-jiu-xian/](https://leetcode-cn.com/problems/permutations/solution/chou-xiang-cheng-jue-ce-shu-yi-ge-pai-lie-jiu-xian/)

来源：⼒扣（LeetCode）

著作权归作者所有。商业转载请联系作者获得授权，⾮商业转载请注明出处。

 N皇后





n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互

攻击。

给你⼀个整数 n ，返回所有不同的 n 皇后问题 的解决⽅案。

每⼀种解法包含⼀个不同的 n 皇后问题 的棋⼦放置⽅案，该⽅案中 'Q' 和 '.' 分别代表了

皇后和空位。

示例 1：

输⼊：n = 4

输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]

解释：如上图所示，4 皇后问题存在两个不同的解法。

示例 2：

输⼊：n = 1

输出：[["Q"]]

提示：

1 <= n <= 9

皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同⼀条横⾏、纵⾏或斜线

上。

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/n-queens

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

我起初的思路

以 4 皇后为例，我画出⼀个搜索树，初始时棋盘的格⼦都是"."。





每⼀⾏，选⼀个格⼦置为"Q"，⼀⾏⾏往下选，第⼀⾏有四种选择。

在选下⼀⾏的皇后时，为了避免列的冲突，有三种选择。

继续选下去，可能会遇到对⻆线冲突，继续选下去没有意义，得不出合法的解。需要回溯。

回溯的套路（可硬记）：

遍历枚举出所有可能的选择。

依次尝试这些选择：作出⼀种选择，并往下递归。

如果这个选择产⽣不出正确的解，要撤销这个选择（将当前的 "Q" 恢复为 "."），回到之前的

状态，并作出下⼀个可⽤的选择。

选择、探索、撤销选择。识别出死胡同，就回溯，尝试下⼀个点，不做⽆效的搜索。

思路修正

我在枚举选择时，规避了⾏和列的冲突，前⾯画的搜索树已经是修剪后的。

但我还是想复杂了，对⻆线冲突和⾏列冲突⼀起作为约束就好，直接进⾏充分剪枝。

即遍历之前的⾏，如果当前的格⼦和之前的皇后们 同列或同对⻆线，则跳过该点（这需要优

化，后⾯会讲）

 你看上图左边两个叶⼦节点，下⼀⾏怎么放都冲突，可选的选项都被剪完了，

 当所有可选的选择迭代完，当前递归分⽀就结束，撤销最后的选择，回到上⼀层，切⼊另

⼀个分⽀。

 当填完第四⾏，如上图的绿钩，⽣成了⼀个解，加⼊解集，并返回（这⾥不返回也⾏，因

为已经做了充分的剪枝，不返回就会⾛⼀遍迭代，递归也结束），开始回溯，继续寻找完

整解。





回溯的三要点

\1. 选择，决定了搜索空间，决定了搜索空间有哪些节点。

\2. 约束，⽤来剪枝，避免进⼊⽆效的分⽀。

\3. ⽬标，决定了什么时候捕获有效的解，提前结束递归，开始回溯。

代码

Runtime: 4 ms, fast er t han 92.71% of Go online submissions for N-Queens.

1 func solveNQueens(n int) [][]string {

2

bd := make([][]string, n)

for i := range bd {

bd[i] = make([]string, n)

for j := range bd[i] {

bd[i][j] = "."

3

4

5

6

7

}

8

}

9

res := [][]string{}

helper(0, bd, &res, n)

return res

10

11

12 }

13 func helper(r int, bd [][]string, res \*[][]string, n int) {

14

if r == n {

temp := make([]string, len(bd))

15

16

for i := 0; i < n; i++ {

17

temp[i] = strings.Join(bd[i], "")

18

}

19

\*res = append(\*res, temp)

return

20

21

}

22

for c := 0; c < n; c++ {

23

if isValid(r, c, n, bd) {

24

bd[r][c] = "Q"

25

helper(r+1, bd, res, n)

26

bd[r][c] = "."

27

}

28

}

23 90 }

31 func isValid(r, c int, n int, bd [][]string) bool {

32

for i := 0; i < r; i++ {

for j := 0; j < n; j++ {

33

34

if bd[i][j] == "Q" && (j == c || i+j == r+c || i-j == r-c) {

return false

35

36

}

37

}

38

}

39

return true

40 }

还可以优化

本题必须记录之前放置皇后的位置，才能结合约束条件去做剪枝。

我每次都调⽤ isValid 遍历⼀遍前⾯的格⼦，效率是不优的。





最好是⽤三个数组或 Set 去记录出现过皇后的列们、正对⻆线们、反对⻆线们，⽤空间换取

时间。

优化后的代码

Runtime: 4 ms, fast er t han 92.71% of Go online submissions for N-Queens.

1 func solveNQueens(n int) [][]string {

2

3

bd := make([][]string, n)

for i := range bd {

bd[i] = make([]string, n)

for j := range bd[i] {

bd[i][j] = "."

4

5

6

7

}

8

}

9

cols := map[int]bool{}

diag1 := map[int]bool{}

diag2 := map[int]bool{}

res := [][]string{}

helper(0, bd, &res, n, cols, diag1, diag2)

return res

10

11

123

14

15

16 }

17 func helper(r int, bd [][]string, res \*[][]string, n int, cols, diag1,

diag2 map[int]bool) {

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39 }

if r == n {

temp := make([]string, len(bd))

for i := 0; i < n; i++ {

temp[i] = strings.Join(bd[i], "")

}

\*res = append(\*res, temp)

return

}

for c := 0; c < n; c++ {

if !cols[c] && !diag1[r+c] && !diag2[r-c] {

bd[r][c] = "Q"

cols[c] = true

diag1[r+c] = true

diag2[r-c] = true

helper(r+1, bd, res, n, cols, diag1, diag2)

bd[r][c] = "."

cols[c] = false

diag1[r+c] = false

diag2[r-c] = false

}

}

401 作者：xiao\_ben\_zhu

42 链接：https://leetcode-cn.com/problems/n-queens/solution/shou-hua-tu-jie-

cong-jing-dian-de-nhuang-hou-wen-t/

43 来源：力扣（LeetCode）





44 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

3.2 | 并查集

 ⼿写代码：省份数量

有 n 个城市，其中⼀些彼此相连，另⼀些没有相连。如果城市 a 与城市 b 直接相连，且城

市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。

省份 是⼀组直接或间接相连的城市，组内不含其他没有相连的城市。

给你⼀个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j

个城市直接相连，⽽ isConnected[i][j] = 0 表示⼆者不直接相连。

返回矩阵中 省份 的数量。

示例 1：

输⼊：isConnected = [[1,1,0],[1,1,0],[0,0,1]]

输出：2

示例 2：

输⼊：isConnected = [[1,0,0],[0,1,0],[0,0,1]]

输出：3

提示：

1 <= n <= 200

n == isConnected.length

n == isConnected[i].length

isConnected[i][j] 为 1 或 0

isConnected[i][i] == 1

isConnected[i][j] == isConnected[j][i]

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/number-of-provinces

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

1 func findCircleNum(isConnected [][]int) int {

2

3

4

5

n := len(isConnected)

if n == 1 {

return 1

}





67

8

uf := generate(n)

for i := 0; i < n; i++ {

for j := i; j < n; j++ {

9

10

11

12

13

14

15

16 }

if isConnected[i][j] == 1 {

uf.union(i, j)

}

}

}

return uf.count

178 type unionFind struct {

19

count int

20

parent []int

21 }

223 func generate(n int) (uf \*unionFind) {

24

uf = &unionFind{}

uf.count = n

25

26

uf.parent = make([]int, n)

for i := 0; i < n; i++ {

uf.parent[i] = i

}

27

28

29

30

return

31 }

323 func (uf \*unionFind) union(p, q int) {

34

if p == q {

35

return

36

}

378

rootP := uf.find(p)

rootQ := uf.find(q)

if rootP == rootQ {

return

39

40

41

42

}

434

uf.parent[rootP] = rootQ

uf.count--

45

46 }

478 func (uf \*unionFind) find(t int) (root int) {

49

root = t

50

for root != uf.parent[root] {

51

root = uf.parent[root]

52

}

534

for t != uf.parent[t] {

55

x := uf.parent[t]

56

uf.parent[t] = root

57

t = x

58

}

56 90

return

61 }

623 作者：lzhlyle





64 链接：https://leetcode-cn.com/problems/number-of-provinces/solution/bing-

cha-ji-by-lzhlyle-zh6l/

65 来源：力扣（LeetCode）

66 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

 ⼿写代码：岛屿数量

给你⼀个由 '1'（陆地）和 '0'（⽔）组成的的⼆维⽹格，请你计算⽹格中岛屿的数量。

岛屿总是被⽔包围，并且每座岛屿只能由⽔平⽅向和/或竖直⽅向上相邻的陆地连接形成。

此外，你可以假设该⽹格的四条边均被⽔包围。

示例 1：

输⼊：grid = [

["1","1","1","1","0"],

["1","1","0","1","0"],

["1","1","0","0","0"],

["0","0","0","0","0"]

]

输出：1

示例 2：

输⼊：grid = [

["1","1","0","0","0"],

["1","1","0","0","0"],

["0","0","1","0","0"],

["0","0","0","1","1"]

]

输出：3

提示：

m == grid.length

n == grid[i].length

1 <= m, n <= 300

grid[i][j] 的值为 '0' 或 '1'

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/number-of-islands

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

1 type UnionFindSet struct {

2

Parents []int // 每个结点的顶级节点





3

SetCount int // 连通分量的个数

4 }

56 func (u \*UnionFindSet) Init(grid [][]byte) {

7

8

row := len(grid)

col := len(grid[0])

count := row\*col

u.Parents = make([]int, count)

for i := 0; i < row; i++ {

for j := 0; j < col; j++ {

u.Parents[i\*col+j] = i\*col+j

if grid[i][j] == '1' {

u.SetCount++

9

10

11

12

13

14

15

16

17

18

19 }

}

}

}

201 func (u \*UnionFindSet) Find(node int) int {

22

if u.Parents[node] == node {

return node

23

24

}

25

root := u.Find(u.Parents[node])

u.Parents[node] = root

return root

26

27

28 }

23 90 func (u \*UnionFindSet) Union(node1 int, node2 int) {

31

root1 := u.Find(node1)

root2 := u.Find(node2)

if root1 == root2 {

return

32

33

34

35

}

36

if root1 < root2 {

u.Parents[root1] = root2

} else {

37

38

39

u.Parents[root2] = root1

}

40

41

u.SetCount--

42 }

43 // 心得：并查集是一种搜索算法（针对聚合的）

44 func numIslands(grid [][]byte) int {

45

46

47

48

49

50

51

52

53

54

// 创建并初始化并查集

u := &UnionFindSet{}

row := len(grid)

col := len(grid[0])

u.Init(grid)

// 根据grid建立相应的并查集，并统计连通分量个数【每连接一次进行减一】

for i := 0; i < row; i++ {

for j := 0; j < col; j++ {

if grid[i][j] == '1' {

// 如果周边四个方向也是1就进行union





55

56

57

58

59

60

61

62

63

64

65

66

67

68

69

70

71

72

73 }

if i - 1 >= 0 && grid[i-1][j] == '1' {

u.Union(i\*col+j, (i-1)\*col+j)

}

if i + 1 < row && grid[i+1][j] == '1' {

u.Union(i\*col+j, (i+1)\*col+j)

}

if j - 1 >= 0 && grid[i][j-1] == '1' {

u.Union(i\*col+j, i\*col+(j-1))

}

if j + 1 < col && grid[i][j+1] == '1' {

u.Union(i\*col+j, i\*col+(j+1))

}

grid[i][j] = '0'

}

}

}

// 返回结果

return u.SetCount

745 作者：bryson-2

76 链接：https://leetcode-cn.com/problems/number-of-islands/solution/bing-cha-

ji-go-by-bryson-2/

77 来源：力扣（LeetCode）

78 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

 ⼿写代码：最⻓连续序列

给定⼀个未排序的整数数组 nums ，找出数字连续的最⻓序列（不要求序列元素在原数组

中连续）的⻓度。

进阶：你可以设计并实现时间复杂度为 O(n) 的解决⽅案吗？

示例 1：

输⼊：nums = [100,4,200,1,3,2]

输出：4

解释：最⻓数字连续序列是 [1, 2, 3, 4]。它的⻓度为 4。

示例 2：

输⼊：nums = [0,3,7,2,5,8,4,6,0,1]

输出：9

提示：

0 <= nums.length <= 104

-109 <= nums[i] <= 109

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/longest-consecutive-sequence





著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

\1. ⽤map记录⼀下数字和索引

\2. ⽤例有重复数字，需要处理⼀下

\3. 看看左右数字是否在map中，有的话，连通它们的索引

\4. 遍历并查集的size数组，看看规模最⼤的⼀个分量有多⼤，就是最⻓连续序列

1 func longestConsecutive(nums []int) int {

2

3

//key : nums[i]; value : i

uf := NewUnionFindSet(len(nums))

4

m := make(map[int]int)

5

for i := 0; i < len(nums); i++ {

6

cur := nums[i]

7

if \_, ok := m[cur]; ok {

8

continue

9

}

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25 }

m[cur] = i

if idx, ok := m[cur - 1]; ok {

uf.Mix(i, idx)

}

if idx, ok := m[cur + 1]; ok {

uf.Mix(i, idx)

}

}

res := 0

for \_, v := range uf.sz {

if v > res {

res = v

}

}

return res

2 678 type UnionFindSet struct {

29

id

sz

[]int

[]int

30

31

count int

32 }

334 func NewUnionFindSet(n int) \*UnionFindSet {

35

36

37

38

34 90

41

42

43

445

46

47

id := make([]int, n)

for i := range id {

id[i] = i

}

sz := make([]int, n)

for i := range sz {

sz[i] = 1

}

return &UnionFindSet{

id:

id,

sz : sz,





48

count: n,

49

}

50 }

512 func (u \*UnionFindSet) Find(p int) int {

53

for p != u.id[p] {

p = u.id[p]

}

54

55

56

return p

57 }

589 func (u \*UnionFindSet) Mix(p, q int) {

60

i := u.Find(p)

j := u.Find(q)

if i == j {

return

61

62

63

64

}

65

if u.sz[i] < u.sz[j] {

u.id[i] = j

u.sz[j] += u.sz[i]

} else {

66

67

68

69

u.id[j] = i

u.sz[i] += u.sz[j]

}

70

71

72

u.count--

73 }

作者：rclove2k

[链接：](https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/bing-cha-ji-lian-tong-lian-xu-shu-zi-de-n9t87/)[https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/bing](https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/bing-cha-ji-lian-tong-lian-xu-shu-zi-de-n9t87/)

[-cha-ji-lian-tong-lian-xu-shu-zi-de-n9t87/](https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/bing-cha-ji-lian-tong-lian-xu-shu-zi-de-n9t87/)

来源：⼒扣（LeetCode）

著作权归作者所有。商业转载请联系作者获得授权，⾮商业转载请注明出处。

3.3 | 字符串

 ⼿写代码：转换成⼩写字⺟

实现函数 ToLowerCase()，该函数接收⼀个字符串参数 str，并将该字符串中的⼤写字⺟

转换成⼩写字⺟，之后返回新的字符串。

示例 1：

输⼊: "Hello"

输出: "hello"

示例 2：

输⼊: "here"

输出: "here"

示例 3：

输⼊: "LOVELY"

输出: "lovely"





来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/to-lower-case

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

解题思路

Go⾥⾯⽆法对字符串修改的，需要转成字节数组

1 func toLowerCase(str string) string {

2

b := []byte(str)

3

for i:=0;i<len(b);i++{

4

if str[i]>='A'&&str[i]<='Z'{

5

b[i]=str[i]+32

6

}

7

}

8

return string(b)

9 }

101 作者：ba-xiang

12 链接：https://leetcode-cn.com/problems/to-lower-case/solution/go-zhuan-zi-

jie-shu-zu-ran-hou-bian-li-by-ba-xiang/

13 来源：力扣（LeetCode）

14 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

 ⼿写代码：最⻓公共前缀

编写⼀个函数来查找字符串数组中的最⻓公共前缀。

如果不存在公共前缀，返回空字符串 ""。

示例 1：

输⼊：strs = ["ﬂower","ﬂow","ﬂight"]

输出："ﬂ"

示例 2：

输⼊：strs = ["dog","racecar","car"]

输出：""

解释：输⼊不存在公共前缀。

提示：

0 <= st rs.lengt h <= 200

0 <= st rs[i].lengt h <= 200

st rs[i] 仅由⼩写英⽂字⺟组成

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/longest-common-preﬁx

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：





解题思路

先找到最短的元素，因为最⻓公共前缀的⻓度肯定⼩于等于这个元素的⻓度

接着遍历最短的元素，和数组中的每个元素的相同位置⽐较看是否相同

如果遇到不同的了，那就返回不同的之前的所有元素

如果遍历完了这个最短元素，说明这个最短元素就是最⻓公共前缀，直接返回

代码

1 func longestCommonPrefix(strs []string) string {

2

3

// 最长的公共前缀的长度肯定小于等于数组中最短的元素

// 所以从这个元素开始当基准

4

short := findShortestInArray(strs)

// 早发现早治疗

5

6

if len(short) == 0 {

7

return ""

8

}

9

// 遍历这个最短的每个位置元素，用来判断是不是相等

for i, v := range short {

10

11

12

13

14

15

16

// 要判断多少次，取决于数组strs中有多少个元素，所以用的len(strs)

for j := 0; j < len(strs); j++ {

// 数组的第j个元素的第i个位置不等于我们的short的第i个位置的元素

// 写成strs[j][i] 是为了和short里面的每个元素一一对应比较

if strs[j][i] != byte(v) {

// 到了第[j][i]个没有匹配上，那么就说明之前的都匹配上了，所以直接

返回[j][:i]

17

return strs[j][:i]

18

}

19

}

20

}

21

// 遍历完short了，说明short就是最长的，直接返回

22

return short

23 }

245 func findShortestInArray(s []string) string {

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

// 空字符数组返回空

if len(s) == 0 {

return ""

}

// 临时定义最短为数组第一个

shortest := s[0]

// 遍历数组每个元素

for \_, v := range s {

// 找到当前小于res

if len(v) < len(shortest) {

// 看看是否是空的，空的说明数组中有空字符，所以最长公共前缀肯定为空

if len(v) == 0 {

return ""

}

// 替换当前最小为当前遍历到的元素

shortest = v





42

}

43

}

44

return shortest

45 }

作者：DCCooper

[链接：](https://leetcode-cn.com/problems/longest-common-prefix/solution/gojie-fa-xiang-xi-zhu-shi-kan-bu-dong-da-si-wo-by-/)[https://leetcode-cn.com/problems/longest-common-preﬁx/solution/gojie-fa-xi](https://leetcode-cn.com/problems/longest-common-prefix/solution/gojie-fa-xiang-xi-zhu-shi-kan-bu-dong-da-si-wo-by-/)

[ang-xi-zhu-shi-kan-bu-dong-da-si-wo-by-/](https://leetcode-cn.com/problems/longest-common-prefix/solution/gojie-fa-xiang-xi-zhu-shi-kan-bu-dong-da-si-wo-by-/)

来源：⼒扣（LeetCode）

著作权归作者所有。商业转载请联系作者获得授权，⾮商业转载请注明出处。

 ⼿写代码：有效的字⺟异位词

给定两个字符串 s 和 t ，编写⼀个函数来判断 t 是否是 s 的字⺟异位词。

示例 1:

输⼊: s = "anagram", t = "nagaram"

输出: t rue

示例 2:

输⼊: s = "rat", t = "car"

输出: f alse

说明:

你可以假设字符串只包含⼩写字⺟。

进阶:

如果输⼊字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？

来源：⼒扣（LeetCode）

链接：https://leetcode-cn.com/problems/valid-anagram

著作权归领扣⽹络所有。商业转载请联系官⽅授权，⾮商业转载请注明出处。

参考回答：

思路

⽤ HashMap 来映射 s 的字符和对应的出现次数。

然后遍历 t ，将对应的字符在 map 中的值减 1，如果所有 value 都变为 0，则返回 t rue。

最多只有 26 个⼩写字符，所以也可以⽤⻓度为 26 的整型数组。

代码

下⾯⼏版的代码都是⽤这个思路，⼤同⼩异

1 func isAnagram(s string, t string) bool {

2

3

4

5

67

8

9

hash := make([]int, 26)

for \_, c := range s {

hash[c-'a']++ // int32类型的Unicode数值相减

}

for \_, c := range t {

if hash[c-'a'] == 0 { // s中没有出现过该字符，返回false

return false





10

}

11

hash[c-'a']-- // 出现过，对应的出现次数-1

12

}

13

for \_, v := range hash { // 如果有一个元素不为0，那就不满足

14

if v != 0 {

15

return false

16

}

17

}

18

return true

19 }

代码2

1 func isAnagram(s string, t string) bool {

2

3

if len(s) != len(t) {

return false

4

}

5

hash := make([]int, 26)

6

for i := 0; i < len(s); i++ { // s t 长度相等

7

hash[s[i]-'a']++

8

hash[t[i]-'a']--

9

}

10

11

12

13

14

15

16 }

for \_, v := range hash {

if v != 0 {

return false

}

}

return true

代码3

1 func isAnagram(s string, t string) bool {

2

34

hash := map[rune]int{}

for \_, c := range s {

5

hash[c]++

6

}

7

for \_, c := range t {

8

if count, ok := hash[c]; !ok || count == 0 {

9

return false

10

11

12

13

14

15

16

17

18

19 }

}

hash[c]-- // 匹配掉一个，就减一个

}

for \_, v := range hash {

if v != 0 {

return false

}

}

return true





代码4

1 func isAnagram(s string, t string) bool {

2

if len(s) != len(t) {

return false

3

4

}

5

6

arr1 := [26]int{}

arr2 := [26]int{}

for i := 0; i < len(s); i++ {

arr1[s[i]-'a']++

arr2[t[i]-'a']++

}

78

9

10

11

12

13 }

return arr1 == arr2

作者：xiao\_ben\_zhu

[链接：](https://leetcode-cn.com/problems/valid-anagram/solution/242-you-xiao-de-zi-mu-yi-wei-ci-by-xiao_ben_zhu/)[https://leetcode-cn.com/problems/valid-anagram/solution/242-you-xiao-de-zi-](https://leetcode-cn.com/problems/valid-anagram/solution/242-you-xiao-de-zi-mu-yi-wei-ci-by-xiao_ben_zhu/)

[mu-yi-wei-ci-by-xiao_ben_zhu/](https://leetcode-cn.com/problems/valid-anagram/solution/242-you-xiao-de-zi-mu-yi-wei-ci-by-xiao_ben_zhu/)

来源：⼒扣（LeetCode）

著作权归作者所有。商业转载请联系作者获得授权，⾮商业转载请注明出处。

